%\part{Optimisation}
%\frame{\partpage}

\begin{frame}{Optimisation}
	\begin{itemize}
		\item \textbf{Optimisation} is the process of making a program \textbf{more efficient}
			in terms of speed, memory usage etc. \pause
		\item \textbf{Macro-optimisation}: optimisation at the program design level,
			e.g.\ choosing algorithms or data structures with more efficient ``big-$O$'' behaviour \pause
		\item \textbf{Micro-optimisation}: optimisation at the code level,
			e.g.\ tweaking individual lines of code
	\end{itemize}
\end{frame}

\begin{frame}{To optimise or not to optimise?}
	Optimisation can \textbf{increase} or \textbf{decrease} software quality,
	depending on what measure of ``quality'' is being used. \pause
	\begin{itemize}
		\item In pairs.
		\item Discuss for \textbf{3 minutes} the impact of optimisation on software quality.
		\item Log on to Socrative \texttt{6E8NSW3IN}
		\item Suggest \textbf{one example} of how optimisation may \textbf{increase} the quality of your software. \pause
		\item Now suggest \textbf{one example} of how optimisation may \textbf{decrease} the quality of your software.
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{center}
		``Rules of optimization:
		
		Rule 1: Don't do it.
		
		Rule 2 (for experts only): Don't do it yet.''
	\end{center}
	\begin{flushright}
		--- Michael A.\ Jackson
	\end{flushright}
\end{frame}

\begin{frame}
	\begin{center}
		``Programmers waste enormous amounts of time thinking about, or worrying about,
		the speed of noncritical parts of their programs, and these attempts at efficiency
		actually have a strong negative impact when debugging and maintenance are considered.
		We \textit{should} forget about small efficiencies, say about 97\% of the time:
		\textbf{premature optimization is the root of all evil}.
		Yet we should not pass up our opportunities in that critical 3\%.''
	\end{center}
	\begin{flushright}
		--- Donald Knuth
	\end{flushright}
\end{frame}

\begin{frame}
	\begin{center}
		``Measure twice, cut once.''
	\end{center}
	\begin{flushright}
		--- Proverb
	\end{flushright}
\end{frame}

\begin{frame}{Profiling}
	\begin{itemize}
		\item A \textbf{profiler} measures which parts of a program take the most time
			and/or use the most memory \pause
		\item Profiling helps to identify \textbf{bottlenecks}:
			the parts of the software that are actually causing performance problems \pause
		\item \textbf{Always} profile to find bottlenecks --- don't try to guess where they are!
	\end{itemize}
\end{frame}

\begin{frame}{Profiling in Visual C++}
	\begin{itemize}
		\item Visual Studio 2015 includes extensive profiling tools \pause
		\item Google ``Visual Studio 2015 diagnostic tools'' for more info
	\end{itemize}
\end{frame}

\begin{frame}{Bottlenecks}
	\begin{itemize}
		\item Where does the software spend most of its time? \pause
		\item Code optimisation is most useful if your program is \textbf{CPU-bound}
			\begin{itemize}
				\item Performing calculations or logical operations \pause
			\end{itemize}
		\item Programs can also be \textbf{GPU-bound}...
			\begin{itemize}
				\item Rendering graphics \pause
			\end{itemize}
		\item ... or \textbf{memory-bound}...
			\begin{itemize}
				\item Accessing data in memory \pause
			\end{itemize}
		\item ... or \textbf{IO-bound}
			\begin{itemize}
				\item Waiting for disk, network, or other external devices \pause
			\end{itemize}
		\item E.g.\ don't waste time optimising a part of the program that is already limited by
			disk or network speed!
	\end{itemize}
\end{frame}

\begin{frame}{Optimisation by compiler}
	\begin{itemize}
		\item When compiling in \textbf{release mode}, the compiler performs many
			micro-optimisations \textbf{automatically} \pause
		\item \textbf{Common programmer mistake}: doing manual micro-optimisations that the compiler would do anyway \pause
		\item Ideally, always profile your code in \textbf{release mode}
	\end{itemize}
\end{frame}
