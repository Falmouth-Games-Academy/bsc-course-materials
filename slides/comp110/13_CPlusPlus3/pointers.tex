\part{Pointers}
\frame{\partpage}

\begin{frame}[fragile]{Pointers}
    \begin{itemize}
        \item A \textbf{pointer} is the address of a memory location \pause
        \item If \lstinline{T} is a type, \lstinline{T*} is the type ``pointer to \lstinline{T}'' \pause
        \item \lstinline{&} is the \textbf{address-of} operator: gets a pointer to something \pause
        \item \lstinline{*} is the \textbf{dereference} operator: gets the thing the pointer points to
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Allocating objects on the heap}
    \begin{itemize}
        \item Objects can be allocated on the heap using the \lstinline{new} keyword \pause
        \item \lstinline{new} gives a pointer to the new instance
    \end{itemize}
    \pause
    \begin{lstlisting}
// To use a parameterless constructor
MyClass* myInstance = new MyClass;

// To use a constructor with parameters
MyClass* myOtherInstance = new MyClass(1, 2, 3);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Deleting objects from the heap}
    \begin{itemize}
        \item Objects instantiated with \lstinline{new} must be deleted using \lstinline{delete} \pause
    \end{itemize}
    \begin{lstlisting}
delete myInstance;
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item Forgetting to do this is a \textbf{memory leak} \pause
        \item Deleting something \textbf{twice} is bad \pause
        \item Trying to \textbf{dereference a deleted pointer} is bad
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Addressing and dereferencing}
    \begin{lstlisting}
int a = 7;

// Address-of operator
int* b = &a;

// Dereferencing
int c = *b;
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item \lstinline{&} gets the \textbf{address} of a variable, i.e.\ a pointer to it
        \item \lstinline{*} \textbf{dereferences} the pointer, i.e.\ looks up the thing it points to
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Socrative \texttt{6E8NSW3IN}}
    \begin{lstlisting}
int a = 7;
int* b = &a;
int c = *b;
    \end{lstlisting}
    Suppose that the variables are assigned to the following memory addresses:
    \begin{center}
        \begin{tabular}{r|ccc}
            \textbf{Variable} & {\lstinline!a!} & {\lstinline!b!} & {\lstinline!c!} \\ \hline
%            \textbf{Variable} & a & b & c \\
            \textbf{Address} & 1000 & 1004 & 1008
        \end{tabular}
    \end{center}
    \pause
    \begin{enumerate}
        \item What is the value of \lstinline{a}? \pause
        \item What is the value of \lstinline{b}? \pause
        \item What is the value of \lstinline{c}?
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Dereferencing for objects}
    \begin{itemize}
        \item This would work...
    \end{itemize}
    \begin{lstlisting}
Circle* myCircle = new Circle(10);
double area = (*myCircle).getArea();
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item \lstinline{->} is a shorthand for dereferencing and accessing a member \pause
        \item The code below is equivalent to the code above, but clearer
    \end{itemize}
    \begin{lstlisting}
Circle* myCircle = new Circle(10);
double area = myCircle->getArea();
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Null pointer}
    \begin{itemize}
        \item Pointers can have a special value \lstinline{nullptr} \pause
        \item This signifies the pointer doesn't point to anything \pause
    \end{itemize}
    \begin{lstlisting}
MyClass* notAnInstance = nullptr;
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item Similar to \lstinline[language=Python]{None} in Python \pause
        \item You may also see \lstinline{NULL} used instead of \lstinline{nullptr} ---
            the meaning is the same
    \end{itemize}
\end{frame}

%\begin{frame}[fragile]{Dangling pointers}
    %\begin{lstlisting}
%delete myInstance;
    %\end{lstlisting}
    %\pause
    %\begin{itemize}
        %\item The instance that \lstinline{myInstance} pointed to has been deleted, but \lstinline{myInstance} still holds its old address \pause
        %\item \lstinline{myInstance} is a \textbf{dangling pointer}, and dereferencing it would certainly be a bug \pause
        %\item Get into the habit of setting pointers to \lstinline{nullptr} after deleting them \pause
        %\begin{itemize}
            %\item Dereferencing a null pointer is still a bug, but will generally crash your program straight away rather than causing obscure errors
        %\end{itemize}
    %\end{itemize}
%\end{frame}

\begin{frame}[fragile]{Polymorphism}
    \begin{itemize}
        \item Can have a pointer to a \textbf{base class} which is actually an instance of a \textbf{derived class}
    \end{itemize}
    \begin{lstlisting}
class Shape { ... };
class Circle : Shape { ... };

Shape* myShape = new Circle(10);
std::cout << myShape.getArea() << std::endl;
    \end{lstlisting}
\end{frame}
