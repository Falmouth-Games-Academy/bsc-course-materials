\part{Variables and types}
\frame{\partpage}

\begin{frame}[fragile]{Variables}
	\begin{columns}[onlytextwidth]
		\begin{column}{0.45\textwidth}
			In Python, variables exist the moment they are assigned to:
			\begin{lstlisting}[language=Python]
a = 10
b = 20
			\end{lstlisting}
			\pause
			Variables can hold values of any type:
			\begin{lstlisting}[language=Python]
a = 10
a = 3.14159
a = "Hello"
			\end{lstlisting}
		\end{column}
		\pause
		\begin{column}{0.45\textwidth}
			In C++, variables must be \textbf{declared} before use, and must be given a \textbf{type}:
			\begin{lstlisting}
int a = 10;
int b = 20;
			\end{lstlisting}
			\pause
			Variables can only hold values of the correct type:
			\begin{lstlisting}
int a = 10;
a = 17;      // OK
a = "Hello"; // Error
			\end{lstlisting}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Integers}
	\begin{itemize}
		\item \lstinline{int} is the basic data type for integers (whole numbers)
	\end{itemize}
	\begin{lstlisting}
int a = 42;
int b = -74965;
int c = 0;
int d = 0x19FD; // Hexadecimal
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item On Windows (32 and 64 bit), \lstinline{int} can store numbers from $-2^{31}$ to $2^{31}-1 \approx \pm 2$ billion \pause
		\item \lstinline{unsigned int} stores \textbf{nonnegative} integers, from 0 to $2^{32} \approx 4$ billion \pause
		\item Other integer types exist, for example \lstinline{long long} is a 64 bit integer
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Floating point numbers}
	\begin{itemize}
		\item \lstinline{float} and \lstinline{double} can store floating point numbers (numbers with a fractional part)
	\end{itemize}
	\begin{lstlisting}
double a = 3.14159;
double b = -42;
double c = 3.0e8; // Scientific notation
float d = 123.456f; // Note the 'f' suffix for float
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item \lstinline{float} uses less space, and can be slightly faster, but is less precise \pause
		\item Generally \lstinline{double} is the better choice
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Characters}
	\begin{itemize}
		\item \lstinline{char} stores a single ASCII character
	\end{itemize}
	\begin{lstlisting}
char foo = 'Q';
char bar = '7';
char baz = '@';
char space = ' ';
char newLine = '\n'; // Escape sequence
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item \lstinline{char} can also be thought of as an 8-bit integer, i.e. an integer between $-128$ and $127$ ---
			C++ makes no distinction between ASCII characters and their numerical codes
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Booleans}
	\begin{itemize}
		\item \lstinline{bool} stores a boolean (true or false) value
	\end{itemize}
	\begin{lstlisting}
bool isAlive = true;
bool isDead = false;
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Vectors}
	\begin{itemize}
		\item \textbf{Vectors} are the C++ equivalent of lists in Python
		\pause
		\item Add \lstinline{#include <vector>} to \texttt{stdafx.h}
		\pause
		\item \lstinline{std::vector<T>} is a vector with elements of type \lstinline{T}
	\end{itemize}
	\pause
	\begin{lstlisting}
std::vector<int> numbers = { 1, 4, 9, 16 };
numbers.push_back(25);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Strings}
	\begin{itemize}
		\item C++ has two main data types for strings:
		\begin{itemize}
			\item \lstinline{char*} or \lstinline{char[]}: low-level array of ASCII characters (more on arrays next week)
			\item \lstinline{std::string}: high-level string class
		\end{itemize}
		\pause
		\item Use \lstinline{std::string} unless you have a compelling reason not to
		\pause
		\item Add \lstinline{#include <string>} to \texttt{stdafx.h}
	\end{itemize}
	\pause
	\begin{lstlisting}
std::string name = "Ed";
std::string message = "Hello " + name + "!";
std::cout << message << std::endl;
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Enumerations}
	\begin{itemize}
		\item An \textbf{enumeration} is a set of named values
	\end{itemize}
	\pause
	\begin{lstlisting}
enum Direction { dirUp, dirRight, dirDown, dirLeft };

Direction playerDirection = dirUp;
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item This is equivalent to using an \lstinline{int} with 0=up, 1=right etc, but is more readable
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Constants}
	\begin{itemize}
		\item The \lstinline{const} keyword can be used to define a ``variable'' whose value cannot change, i.e.\ read only
	\end{itemize}
	\pause
	\begin{lstlisting}
const int x = 7;
std::cout << x << std::endl; // OK
x = 12; // Error
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Declaring variables}
	\begin{itemize}
		\item A variable declaration must specify a \textbf{type}, and one or more \textbf{variable names}:
	\end{itemize}
	\begin{lstlisting}
int i, j, k;
bool isDead;
std::string playerName;
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item A variable declaration can optionally specify an \textbf{initial value}:
	\end{itemize}
	\begin{lstlisting}
int i = 0, j = 1, k = 2;
bool isDead = false;
std::string playerName = "Ed";
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Initial values}
	\begin{itemize}
		\item If the initial value is omitted, what happens depends on the type: \pause
		\item Basic data types (\lstinline{int, double, bool, char} etc): the value is undefined --- whatever data happened
		to be in that memory location already \pause
		\begin{itemize}
			\item Your code should \textbf{never} read an uninitialised variable --- doing so is \textbf{always} a bug \pause
		\end{itemize}
		\item Object types (\lstinline{std::vector, std::string} etc): depends on the type (consult the documentation) \pause
		\begin{itemize}
			\item \lstinline{std::vector} and \lstinline{std::string} are both initialised to empty
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Scope}
	\begin{itemize}
		\item The \textbf{scope} of a variable is the region of the program where it exists \pause
		\item Generally the scope of a variable begins when it is declared,
		and ends when the block in which it is declared ends \pause
	\end{itemize}
	\begin{lstlisting}
int x = 7;
if (x > 5)
{
    int y = x * 2;
    std::cout << x << std::endl; // OK
    std::cout << y << std::endl; // OK
}
std::cout << x << std::endl; // OK
std::cout << y << std::endl; // Error
	\end{lstlisting}
\end{frame}
