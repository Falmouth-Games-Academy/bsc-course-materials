\part{The build process}
\frame{\partpage}

\begin{frame}{Executing programs}
    \begin{itemize}
        \item CPUs execute \textbf{machine code} \pause
        \item Programs must be \textbf{translated} into machine code for execution \pause
        \item There are three main ways of doing this: \pause
        \begin{itemize}
            \item An \textbf{interpreter} is an application which reads the program source code and executes it directly \pause
            \item A \textbf{compiler} is an application which converts the program source code into executable machine code \pause
            \item A \textbf{just-in-time (JIT) compiler} is halfway between the two --- it compiles the program on-the-fly
                at runtime
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Examples}
	\begin{columns}[t,onlytextwidth]
		\begin{column}{0.3\textwidth}
		    Interpreted:
		    \begin{itemize}
		        \item Python
		        \item Lua
		        \item Bespoke scripting languages
		    \end{itemize}
		\end{column} \pause
		\begin{column}{0.3\textwidth}
		    Compiled:
		    \begin{itemize}
		        \item C
		        \item C++
		        \item Swift
		    \end{itemize}
		\end{column} \pause
		\begin{column}{0.3\textwidth}
		    JIT compiled:
		    \begin{itemize}
		        \item Java
		        \item C\#
		        \item JavaScript (in modern web browsers)
		        \item Jython
		    \end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{Interpreter vs compiler}
    \begin{itemize}
        \item Run-time efficiency: compiler $>$ interpreter \pause
        \begin{itemize}
            \item The compiler translates the program \textbf{in advance}, on the developer's machine \pause
            \item The interpreter translates the program \textbf{at runtime}, on the user's machine \pause
        \end{itemize}
        \item Portability: compiler $<$ interpreter \pause
        \begin{itemize}
            \item A compiled program can only run on the operating system and CPU architecture it was compiled for \pause
            \item An interpreted program can run on any machine, as long as a suitable interpreter is available \pause
        \end{itemize}
        \item JIT compilers have similar pros/cons to interpreters \pause
        \item For games, run-time efficiency is usually much more important than portability
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{The C++ build process}
    \textbf{Preprocessor} \pause
    \begin{itemize}
        \item Replaces \lstinline{#include} directives with the contents of the appropriate header files \pause
        \item Handles other preprocessor directives (\lstinline{#define}, \lstinline{#if} etc --- more on these another time) \pause
    \end{itemize}
    \textbf{Compiler} \pause
    \begin{itemize}
        \item Translates each source file into an \textbf{object file} containing machine code \pause
    \end{itemize}
    \textbf{Linker} \pause
    \begin{itemize}
        \item Combines the object files together with any external libraries to produce an \textbf{executable}
            (on Windows, a .exe file)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{The C++ build process}
    \includegraphics[width=\textwidth]{compiler_flowchart.pdf}
\end{frame}

\begin{frame}[fragile]{Modular design revisited}
    \begin{itemize}
        \item Your code can call any function for which there is a \textbf{declaration} in the current file
            (in the file itself or \lstinline{#include}d) \pause
        \item The \textbf{definition} of the function may be in another file \pause
        \item The \textbf{linker} resolves the function call in this case
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Incremental compilation}
    \begin{itemize}
        \item Compilation can take a long time \pause
        \item Visual C++ does \textbf{incremental compilation}: only recompiles source files that have changed \pause
        \item Visual C++ uses \textbf{precompiled headers}: anything \lstinline{#include}d in \texttt{stdafx.h}
            is only compiled when it changes \pause
        \item Use \textbf{Build $\to$ Clean} or \textbf{Build $\to$ Rebuild} to force everything to be recompiled
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Build configuration in VC++}
    \begin{center}
        \includegraphics[width=0.6\textwidth]{vcpp_build_toolbar.PNG}
    \end{center}
     \pause
    \begin{itemize}
        \item Configuration:
        \begin{itemize}
            \item \textbf{Debug} allows use of the Visual C++ debugger \pause
            \item \textbf{Release} produces optimised code --- usually 2--10 $\times$ faster than Debug \pause
            \item Generally use Debug for development, Release for optimisation and distributing the finished application \pause
        \end{itemize}
        \item Platform:
        \begin{itemize}
            \item \textbf{x86} runs on 32-bit and 64-bit versions of Windows \pause
            \item \textbf{x64} runs on 64-bit Windows only \pause
            \item Generally use x86 for maximum compatibility, x64 for apps which need to use $>2$GB memory
                or where a significant speed benefit is measured
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Anatomy of a Visual C++ solution}
    \begin{itemize}
        \item A \textbf{project} (.vcxproj) is a collection of source files
            which make up a single application or library \pause
        \item A \textbf{solution} (.sln) is a collection of projects \pause
        \item The following are intermediate files
        \begin{itemize}
            \item .sdf files (Visual C++ navigation info)
            \item ipch folder (precompiled headers)
            \item Debug and Release folders (compiled object code and executables) \pause
        \end{itemize}
        \item These files can be deleted to save space, and should be in your \texttt{.gitignore} file
            to prevent them being uploaded to GitHub
    \end{itemize}
\end{frame}
