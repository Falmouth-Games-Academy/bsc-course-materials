\part{Variables and types}
\frame{\partpage}

\begin{frame}[fragile]{Variables}
	\begin{columns}[onlytextwidth]
		\begin{column}{0.45\textwidth}
			In Python, variables exist the moment they are assigned to:
			\begin{lstlisting}[language=Python]
a = 10
b = 20
			\end{lstlisting}
			\pause
			Variables can hold values of any type:
			\begin{lstlisting}[language=Python]
a = 10
a = 3.14159
a = "Hello"
			\end{lstlisting}
		\end{column}
		\pause
		\begin{column}{0.45\textwidth}
			In C++, variables must be \textbf{declared} before use, and must be given a \textbf{type}:
			\begin{lstlisting}
int a = 10;
int b = 20;
			\end{lstlisting}
			\pause
			Variables can only hold values of the correct type:
			\begin{lstlisting}
int a = 10;
a = 17;      // OK
a = "Hello"; // Error
			\end{lstlisting}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Basic data types}
	\begin{itemize}
		\item \lstinline{int}: an integer (whole number)
			\begin{center} \lstinline{7} \qquad \lstinline{136} \qquad \lstinline{-74965} \qquad \lstinline{0} \end{center}
		\pause
		\item \lstinline{double}: a floating point number
			\begin{center} \lstinline{3.14159} \qquad \lstinline{136.0} \qquad \lstinline{-35.25825} \qquad \lstinline{.5} \end{center}
		\pause
		\item \lstinline{bool}: a boolean value
			\begin{center} \lstinline{true} \qquad \lstinline{false} \end{center}
		\pause
		\item \lstinline{char}: an ASCII character
			\begin{center} \lstinline{'Q'} \qquad \lstinline{'7'} \qquad \lstinline{'@'} \qquad \lstinline{' '} \qquad \lstinline{'\n'} \end{center}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Vectors}
	\begin{itemize}
		\item \textbf{Vectors} are the C++ equivalent of lists in Python
		\pause
		\item Add \lstinline{#include <vector>} to \texttt{stdafx.h}
		\pause
		\item \lstinline{std::vector<T>} is a vector with elements of type \lstinline{T}
	\end{itemize}
	\pause
	\begin{lstlisting}
std::vector<int> numbers = { 1, 4, 9, 16 };
numbers.push_back(25);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Strings}
	\begin{itemize}
		\item C++ has two main data types for strings:
		\begin{itemize}
			\item \lstinline{char*} or \lstinline{char[]}: low-level array of ASCII characters (more on arrays next week)
			\item \lstinline{std::string}: high-level string class
		\end{itemize}
		\pause
		\item Use \lstinline{std::string} unless you have a compelling reason not to
		\pause
		\item Add \lstinline{#include <string>} to \texttt{stdafx.h}
	\end{itemize}
	\pause
	\begin{lstlisting}
std::string name = "Ed";
std::string message = "Hello " + name + "!";
std::cout << message << std::endl;
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Enumerations}
	\begin{itemize}
		\item An \textbf{enumeration} is a set of named values
	\end{itemize}
	\pause
	\begin{lstlisting}
enum Direction { dirUp, dirRight, dirDown, dirLeft };

Direction playerDirection = dirUp;
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item This is equivalent to using an \lstinline{int} with 0=up, 1=right etc, but is more readable
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Constants}
	\begin{itemize}
		\item The \lstinline{const} keyword can be used to define a ``variable'' whose value cannot change, i.e.\ read only
	\end{itemize}
	\pause
	\begin{lstlisting}
const int x = 7;
std::cout << x << std::endl; // OK
x = 12; // Error
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Declaring variables}
	\begin{itemize}
		\item A variable declaration must specify a \textbf{type}, and one or more \textbf{variable names}:
	\end{itemize}
	\begin{lstlisting}
int i, j, k;
bool isDead;
std::string playerName;
	\end{lstlisting}
	\begin{itemize}
		\item A variable declaration can optionally specify an \textbf{initial value}:
	\end{itemize}
	\begin{lstlisting}
int i = 0, j = 1, k = 2;
bool isDead = false;
std::string playerName = "Ed";
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Initial values}
	\begin{itemize}
		\item If the initial value is omitted, what happens depends on the type: \pause
		\item Basic data types (\lstinline{int, double, bool, char} etc): the value is undefined --- whatever data happened
		to be in that memory location already \pause
		\begin{itemize}
			\item Your code should \textbf{never} read an uninitialised variable --- doing so is \textbf{always} a bug \pause
		\end{itemize}
		\item Object types (\lstinline{std::vector, std::string} etc): depends on the type (consult the documentation) \pause
		\begin{itemize}
			\item \lstinline{std::vector} and \lstinline{std::string} are both initialised to empty
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Scope}
	\begin{itemize}
		\item The \textbf{scope} of a variable is the region of the program where it exists \pause
		\item Generally the scope of a variable begins when it is declared,
		and ends when the block in which it is declared ends \pause
	\end{itemize}
	\begin{lstlisting}
int x = 7;
if (x > 5)
{
    int y = x * 2;
    std::cout << x << std::endl; // OK
    std::cout << y << std::endl; // OK
}
std::cout << x << std::endl; // OK
std::cout << y << std::endl; // Error
	\end{lstlisting}
\end{frame}
