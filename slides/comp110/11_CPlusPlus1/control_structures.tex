\part{Control structures}
\frame{\partpage}

\begin{frame}[fragile]{If statement}
	\begin{lstlisting}
if (x > 0)
{
    std::cout << "x is positive" << std::endl;
}
else if (x < 0)
{
    std::cout << "x is negative" << std::endl;
}
else
{
    std::cout << "x is neither positive nor negative" << std::endl;
}
	\end{lstlisting}
    \pause
    \begin{itemize}
        \item Condition is always in parentheses \lstinline{( )}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Conditions}
    \begin{itemize}
        \item Numerical comparison operators work just like Python:
        \lstinline{==  !=  <  >  <=  >=}
        \item Boolean logic operators look a little different
    \end{itemize}
    Python uses \lstinline[language=Python]{and, or, not}
    \begin{lstlisting}[language=Python]
if not (x < 0 or x > 100) and not (y < 0 or y > 100):
    print "Point is in rectangle"
    \end{lstlisting}
    C++ uses \lstinline{&&, ||, !}
    \begin{lstlisting}[language=Python]
if (!(x < 0 || x > 100) && !(y < 0 || y > 100))
{
    std::cout << "Point is in rectangle" << std::endl;
}
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Single-statement blocks}
    \begin{itemize}
        \item In many cases, if a block contains only a single statement then the curly braces can be omitted
    \end{itemize}
    \begin{lstlisting}
if (x > 0)
    std::cout << "x is positive" << std::endl;
else if (x < 0)
    std::cout << "x is negative" << std::endl;
else
    std::cout << "x is neither positive nor negative" << std::endl;
    \end{lstlisting}
    \begin{itemize}
        \item Careless use of this can lead to difficult-to-find bugs
    \end{itemize}
    \begin{lstlisting}
// This code is wrong!
if (z == 0)
    x = 0; y = 0;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Switch statement}
	\begin{lstlisting}
switch (x)
{
case 0:
    std::cout << "zero" << std::endl;
    break;
case 1:
    std::cout << "one" << std::endl;
    break;
case 2:
    std::cout << "two" << std::endl;
    break;
default:
    std::cout << "something else" << std::endl;
    break;
}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{While loop}
	\begin{lstlisting}
while (x > 0)
{
    std::cout << x << std::endl;
    x--;
}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Do-while loop}
	\begin{lstlisting}
do
{
    std::cout << x << std::endl;
    x--;
} while (x > 0);
	\end{lstlisting}
	\pause
	\begin{itemize}
		\item \lstinline{while} loop checks the condition \textbf{before} executing the loop body \pause
		\item \lstinline{do-while} loop checks the condition \textbf{after} executing the loop body \pause
		\item e.g. if \lstinline{x == 0} to begin with, the \lstinline{while} body does not execute, the \lstinline{do-while} body executes once
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{For-each loop}
	\begin{lstlisting}
std::vector<int> numbers { 1, 3, 5, 7, 9 };

for each (int x in numbers)
{
    std::cout << x << std::endl;
}
	\end{lstlisting}
    \pause
	\begin{itemize}
		\item This works like the \lstinline{for} loop in Python
		\item Used for iterating over data structures
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{For loop}
	\begin{lstlisting}
for (int i=0; i<10; i++)
{
    std::cout << i << std::endl;
}
	\end{lstlisting}
    \begin{itemize}
        \item In Python, this would be written as
    \end{itemize}
	\begin{lstlisting}[language=Python]
for i in range(10):
    print i
	\end{lstlisting}
\end{frame}
