\part{Statics and singletons}
\frame{\partpage}

\begin{frame}{Static members}
    \begin{itemize}
        \item Class members (methods and fields) can be marked as \lstinline{static} \pause
        \item They are then \textbf{shared} across \textbf{all instances} of the class \pause
        \item Static members can be accessed from \textbf{outside} the class using \lstinline{::} notation
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{The singleton pattern}
    \begin{itemize}
        \item A \textbf{singleton} class has a \textbf{single static instance} \pause
        \item A \textbf{static} \lstinline{getInstance} function returns a \textbf{reference} to the instance \pause
        \item There is \textbf{one and only one} instance --- creating new instances is not allowed,
            neither is destroying the existing instance
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    In \texttt{TextureManager.h}
    \begin{lstlisting}
class TextureManager
{
public:
    static TextureManager& getInstance()
    { return instance; }
    
    Texture* getTexture(const std::string& name);
    
private:
    TextureManager() { };
    static TextureManager instance;
};
    \end{lstlisting} \pause
    In \texttt{TextureManager.cpp}
    \begin{lstlisting}
#include "TextureManager.h"

TextureManager TextureManager::instance;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    Key points: \pause
    \begin{itemize}
        \item Constructor is \textbf{private} to prevent creation of extra instances \pause
        \item \lstinline{instance} and \lstinline{getInstance} are \textbf{static}, everything else is \textbf{not static} \pause
        \item Static variables must be \textbf{instantiated} in a \texttt{.cpp} file
            \begin{itemize}
                \item Optionally with constructor parameters
            \end{itemize} \pause
    \end{itemize}
    Example usage:
    \begin{lstlisting}
Texture* texture = TextureManager::getInstance().getTexture("player.png");
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Statics and initialisation}
    \begin{itemize}
        \item Static members are initialised at the \textbf{very start of the program} \pause
            \begin{itemize}
                \item I.e.\ \textbf{before} \lstinline{main()} is entered \pause
            \end{itemize}
        \item The order of initialisation is \textbf{undefined} \pause
            \begin{itemize}
                \item \textbf{Do not} make your static initialisation code rely on other statics having been initialised already ---
                    this \textbf{will} cause obscure bugs! \pause
            \end{itemize}
        \item Further reading: \url{https://isocpp.org/wiki/faq/ctors#static-init-order} \pause
        \item Consider using the \textbf{construct on first use} idiom if your singleton class
            has a complex constructor
    \end{itemize}
\end{frame}

