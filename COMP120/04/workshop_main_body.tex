% Adjust these for the path of the theme and its graphics, relative to this file
%\usepackage{beamerthemeFalmouthGamesAcademy}
\usepackage{../../beamerthemeFalmouthGamesAcademy}
\usepackage{multimedia}
\graphicspath{ {../../} }

% Default language for code listings
\lstset{language=Python,
        morekeywords={each,in,nullptr,string, Color, Bitmap, GetPixel, SetPixel}
}

% For strikethrough effect
\usepackage[normalem]{ulem}
\usepackage{wasysym}

\usepackage{pdfpages}

% http://www.texample.net/tikz/examples/state-machine/
\usetikzlibrary{arrows,automata}

\setbeamertemplate{navigation symbols}{}

\input{../../commands}

\begin{document}
\title{\sessionnumber: Tinkering Graphics III}
\subtitle{\modulecode: \moduletitle}

\frame{\titlepage} 

\begin{frame}
	\frametitle{Learning Outcomes}
	\begin{itemize}
		\item \textbf{Explain how} to duplicate parts of an image
		\item \textbf{Explain how} to identify the spaces and features of an image
		\item \textbf{Apply} mathematical knowledge to \textbf{write} computer programs that manipulate the spaces and features of an image
		\item \textbf{Implement} executable code that can `tinker' graphics
	\end{itemize}
\end{frame}

\fullbleed{ada-mirror}

\begin{frame}
	\frametitle{Mirroring}
	
	\begin{itemize}		
		\item Mirroring is averaging across pixels
		\item A mirror will:
		\begin{itemize}
			\item Define a dimension of inflexion
			\item Duplicate pixels from the one side of the inflexion to the other, in reverse order
		\end{itemize}	
	\end{itemize}
\end{frame}

\fullbleed{ada-mirror2}

\begin{frame}[fragile]
	\frametitle{Source Code: Mirroring (1)}
	
\begin{lstlisting}
private static Bitmap mirrorVertical(string source) 	
	Bitmap bmp = new Bitmap(source);
	int width = bmp.Width;
	int height = bmp.Height;		
	for (int ty = 0, by = height-1; ty < height/2; ty++, 
		by--) {
		for (int x = 0; x < width; x++){
			Color p = bmp.GetPixel(x, ty);
			bmp.SetPixel(x, ty, p);
			bmp.SetPixel(x, by, p);
		}
	}
}
\end{lstlisting}
Note: When defining the initial value for bottom y (by) we minus 1 to avoid the creation of a gap in the mirror

\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code: Mirroring (2)}
	
\begin{lstlisting}
private static Bitmap mirrorHorizontal(string source) 	
	Bitmap bmp = new Bitmap(source);
	int width = bmp.Width;
	int height = bmp.Height;		
	for (int y = 0; y < height; y++) {
		for (int lx = 0, rx = width-1; lx <
		width/2+1; lx++, rx--) {
			Color p = bmp.GetPixel(lx, y);
			bmp.SetPixel(lx, y, p);
			bmp.SetPixel(rx, y, p);
		}
	}
}
\end{lstlisting}

\end{frame}

\begin{frame}
	\frametitle{Activity \#1: Mirroring}
	
	In pairs:
	
	\vspace{2em}
	
	\begin{itemize}		
		\item Use your function to repair the temple
		\item Post your repaired temple on Slack!
	\end{itemize}
\end{frame}

\fullbleed{repair_the_temple}

\begin{frame}
	\frametitle{Edge Detection}
	
	\begin{itemize}		
		\item Blurring is averaging across pixels
		\item Edge detection is looking for \textit{differences} between pixels:
		\begin{itemize}
			\item We draw lines that our eyes see --- where the luminance changes
		\end{itemize}	
		\item If the pixel changes left-to-right, or up-and-down, make a pixel black. Else, white.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code: Edge Detection}
	
\begin{lstlisting}
private static Bitmap mirrorHorizontal(string source) {  
	Bitmap bmp = new Bitmap(source);
	int width = bmp.Width;
	int height = bmp.Height;  
	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			Color pixel = bmp.GetPixel(x, y);
			Color nextPixel = bmp.GetPixel(x + 1, y + 1);
			int pixelSum = pixel.R + pixel.G + pixel.B;
			int nextPixelSum = nextPixel.R + nextPixel.G
			+ nextPixel.B;
			int diff = Math.Abs(nextPixelSum - pixelSum);
		}
	}
	return bmp;
}
\end{lstlisting}

\small Note: This will create an error due to an overflow exception. You will need to create a method to fix the error.

\end{frame}

\fullbleed{seahorse}

\begin{frame}[fragile]
	\frametitle{Source Code: Edge Detection (1)}
	
\begin{lstlisting}
private static Bitmap drawBetterEdges(string source) {  
	Bitmap bmp = new Bitmap(source);
	int width = bmp.Width;
	int height = bmp.Height;
	Bitmap ebmp = new Bitmap(bmp.Width, bmp.Height);
	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++)	{
			Color here = ebmp.GetPixel(x, y);
			Color right = bmp.GetPixel(x + 1, y)
			Color down = bmp.GetPixel(x, y + 1);
			int hereL = (here.R + here.G + here.B)/3;
			int downL = (down.R + down.G + down.B)/3;
			int rightL = (right.R + right.G + right.B)/3;
...
\end{lstlisting}

Note: Once again this will create an error due to an overflow exception. You will need to create a method to fix the error.

\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code: Edge Detection (2)}
	
\begin{lstlisting}
...
			if (Math.Abs(hereL - downL) > 20 && 
			Math.Abs(hereL - rightL) > 20) {
				ebmp.SetPixel(x, y, Color.FromArgb(255, 
				255, 255, 255));
			}
			if (Math.Abs(hereL - downL) <= 20 && 
			Math.Abs(hereL - rightL) <= 20) {
				ebmp.SetPixel(x, y, Color.FromArgb(255, 
				0, 0, 0));
			}	
		}	
	}
}

\end{lstlisting}

\end{frame}

\fullbleed{butterfly}

\begin{frame}
	\frametitle{Activity \#2: Edge Detection}
	
	In pairs:
	
	\vspace{2em}
	
	\begin{itemize}		
		\item Setup a basic project in PyGame
		\item Refer to the following documentation
		\item Refactor the function: \texttt{drawBetterEdges(picture)} to use better variable names
		\item Test your solution
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Background Subtraction}
	
	\begin{itemize}		
		\item Let's say that you have a picture of someone, and a picture of the same place (same background) without the someone there,
		could you subtract out the background and leave the picture of the person?
		\item Maybe even change the background?
		\item What we most need to do is to figure out whether the pixel in the Person shot is the same as the in the Background shot.
		\item Will they be the EXACT same colour?  Probably not.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code Part A: Background Subtraction}
	
\begin{lstlisting}
 private static Bitmap swapBackground(string front, 
 string back, string newBack, int tolerance)
{
	Bitmap bmp = new Bitmap(front);
	Bitmap bbmp = new Bitmap(back);
	Bitmap nbmp = new Bitmap(newBack);
	int width = bmp.Width;
	int height = bmp.Height;
	Color p;
	Color bp;
	Color nbp;
...
\end{lstlisting}

Note: This source code excerpt will not work in PyGame.

\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code Part B: Background Subtraction}
	
	\begin{lstlisting}
...		
	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			p = bmp.GetPixel(x, y);
			bp = bbmp.GetPixel(x, y);
			if (GetDistance(p,bp) < tolerance) {
				nbp = nbmp.GetPixel(x, y);
				bmp.SetPixel(x, y, nbp);
			}
		}
	}	
	return bmp;
}
	\end{lstlisting}
	
	Note: This source code assumes that you have already created a function called 'GetDistance'.
	
\end{frame}

\fullbleed{katie_nomoon}

\fullbleed{katie_forest}

\begin{frame}
	\frametitle{Problems}
	
	\begin{itemize}		
		\item We've got places where we got pixels swapped that we didn't want to swap
		\item We've got places where we want pixels swapped, but didn't get them swapped
		\begin{itemize}
			\item Shirt stripes
			\item Shadows
			\item etc.
		\end{itemize}	
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Activity \#3: Background Subtraction}
	
	In pairs:
	
	\vspace{2em}
	
	\begin{itemize}		
		\item Setup a forms project in Visual Basic
		\item Implement chroma key as a form of background subtraction
		\item Use your previous experience with isolating colour to implement this.
		\item Test your solution
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code - Part 1: Collage}
	
\begin{lstlisting}
private static Bitmap swapBackground(string source, 
string canvas, int targetX, int targetY)
{
	Bitmap bmp1 = new Bitmap(source);
	Bitmap bmp2 = new Bitmap(canvas);
	int width1 = bmp1.Width;
	int height1 = bmp1.Height;
	int width2 = bmp2.Width;
	int height2 = bmp2.Height;
...	
\end{lstlisting}
Note: \textbf{Source} represents the image to overlay and the \textbf{Canvas} is the background image. \textbf{targetX} and \textbf{targetY} are the offsets from the top left of the canvas.

\end{frame}

\begin{frame}[fragile]
	\frametitle{Source Code - Part 2: Collage}
	
	\begin{lstlisting}
...	
	for (int y = 0; y < height2; y++) {
		for (int x = 0; x < width2; x++) {
			if (x >= xpos && x < width1+xpos) {
				if (y >= ypos && y < height1+ypos) {
					bmp2.SetPixel(x, y, bmp1.GetPixel
					(x-xpos, y-ypos));
				}
			}
			bmp2.SetPixel(x, y, bmp2.GetPixel(x, y));
		}
	}
	return bmp2;
}
	\end{lstlisting}
	
\end{frame}

\fullbleed{copy_1}
\fullbleed{copy_2}
\fullbleed{copy_3}
\fullbleed{copy_4}
\fullbleed{road-tiles}

\begin{frame}
	\frametitle{Activity \#4: Collage}
	
	In pairs:
	
	\vspace{2em}
	
	\begin{itemize}		
		\item Find some smaller images online
		\item Integrate the collage algorithm into your tinkering graphics project
		\item Create a routine that can layout a series of images in a defined sequence
		\item Use this to create a collage of the images you found
	\end{itemize}
\end{frame}

\begin{frame}{Sprite Sheets and Animations}
	Review this article on Code Project by Sasha Djurovic which is a forms application for creating sprite animations 
	
	\vspace{2em}
	
	\url{https://www.codeproject.com/Articles/1896/Sprite-manipulation-in-C}
	
\end{frame}

\begin{frame}
	\frametitle{Activity \#5: Sprite Sheets}
	
	In pairs:
	
	\vspace{2em}
	
	\begin{itemize}		
		\item Find a sprite sheet online
		\item Take the project code and see if you can manipulate it to create your own forms application
		\item Animate something
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{What Next?}
	
	If you have implemented all of these algorithms, then use the rest of the workshop to:
	
	\vspace{2em}
	
	\begin{itemize}	
		\item You now have a range of image manipulation algorithms at your disposal
		\item You only need to successfully implement and repurpose a set of these to do well on your Tinkering Graphics assignment!
		\item So, finish implementing the algorithms needed to complete your coursework
		\item Tidy up your code, ready for next session's peer-review activity
		\item Extend the code beyond the brief as appropriate to your particular game
	\end{itemize}
\end{frame}

\end{document}
