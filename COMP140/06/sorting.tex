\part{Operations on collections}
\frame{\partpage}

\begin{frame}{Sorting}
	\begin{itemize}
		\pause \item Sorting is where we order the items in a collection in a specific order
		\pause \item There are a whole bunch of sorting algorithms including; Insertion sort, Heap sort, Quick sort (please read about these!)
		\pause \item In C++, this depends on the compiler implementation 
		\pause \item Most of the common data types don't need additional work
		\pause \item For custom classes, we have to write our own comparison
	\end{itemize}
\end{frame}

\begin{frame}{Sorting C++}
\begin{itemize}
	\pause \item There are few ways to sort a collection
	\begin{enumerate}
		\pause \item Provide a custom function for the sort
		\pause \item Provide a lambda expression for the sort
		\pause \item Your own class has to override the < operator
	\end{enumerate}
	\pause \item Often you will use option 3 as the default sort
	\pause \item Which then be override by option 1 
	\pause \item 2 is probably the more modern way of doing it, but syntax can be confusing
	\pause \item You have to include the \textbf{<algorithm>} header file
\end{itemize}
\end{frame}

\begin{frame}[fragile]{C++ Example - Sorting with Function }
\begin{lstlisting}
struct Character
{
std::string name;
int health;
int strength;
}

bool sortByHealth(Character a, Character b){return a.health<b.health;}

//Adding omitted!
vector<Character> characters;

//Sort by health
sort(characters.begin(), characters.end(), sortByHealth);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{C++ Example - Sorting < operator }
\begin{lstlisting}
struct Character
{
std::string name;
int health;
int strength;

bool operator <(const Character& other) const {return name<other.name;}
}

//Adding omitted!
vector<Character> characters;

//Sort by health
sort(characters.begin(), characters.end());
\end{lstlisting}
\end{frame}
