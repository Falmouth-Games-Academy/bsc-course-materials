\part{Dynamic Array}
\frame{\partpage}

\begin{frame}{The Problem}
	\begin{itemize}
		\pause \item Arrays in C\# are fixed in size
		\pause \item During development you need to know exactly how many item are going to be in the array
		\pause \item If you need to add elements and you don't have enough space, you will need to carry out the following
		\begin{itemize}
			\pause \item Create a new array of the appropriate size 
			\pause \item Copy elements from the old array into this new one
			\pause \item Destroy the old array
			\pause \item Add in the new element
		\end{itemize}
		\pause \item The above process can be quite costly
	\end{itemize}
\end{frame}

\begin{frame}{The Solution}
	\begin{itemize}
		\pause \item Luckily in most programming languages we have a Data Structure which grows in size when we require it 
		\begin{itemize}
			\pause \item In C\# we have the \textbf{List} class
		\end{itemize}
		\pause \item These classes have the same properties as an array
		\begin{itemize}
			\pause \item Items are located contiguously in memory 
			\pause \item We can randomly access elements using an index
			\pause \item We can iterate through each element
		\end{itemize}
		\pause \item You should consider using a Dynamic Array over a normal array
		\pause \item One caveat, Dynamic Arrays are slightly more expensive!
	\end{itemize}
\end{frame}

\begin{frame}{Use Case}
	\begin{itemize}
		\pause \item Manage Enemies as they are spawned into the scene
		\pause \item Keep track of players as they are added into the game
		\pause \item Inventory systems 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{C\# List
	 Example}
			\begin{lstlisting}
			List<int> scores=new List<int>();
			scores.Add(100);
			scores.Add(200);
			foreach(int score in scores)
			{
				Debug.Log("Score is "+score.ToString());
			}
			int player1Score=scores[0];
			scores.Remove(100);
			\end{lstlisting}
\end{frame}

\begin{frame}{Additional Notes}
	\begin{itemize}
		\pause \item Try to avoid insertion/deleting in the middle of the collection
		\pause \item Searching the collection is linear and will increase as more elements are added (O(n))
		\pause \item insertion/deleting at the end of the collection is constant in performance (O(1)) 
	\end{itemize}
\end{frame}
