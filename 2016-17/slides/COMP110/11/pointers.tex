\part{Pointers}
\frame{\partpage}

\begin{frame}[fragile]{Pointers}
    \begin{itemize}
        \item A \textbf{pointer} is the address of a memory location \pause
        \item If \lstinline{T} is a type, \lstinline{T*} is the type ``pointer to \lstinline{T}'' \pause
        \item \lstinline{&} is the \textbf{address-of} operator: gets a pointer to something \pause
        \item \lstinline{*} is the \textbf{dereference} operator: gets the thing the pointer points to
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Classes in C++}
	\begin{lstlisting}
class MyClass
{
public:
	MyClass() { /* constructor */ }
	~MyClass() { /* destructor */ }
	
	void myMethod();
	int anotherMethod(float foo);
	
	int myField;
	bool anotherField
};
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Allocating objects on the stack}
	\pause
	\begin{lstlisting}
// Calls a parameterless constructor
MyClass instance;

// Calls a constructor with parameters
MyClass otherInstance(1, 2, 3);
	\end{lstlisting}
	\pause Beware though --- these instances are \textbf{destroyed} when the variable goes out of scope!
\end{frame}

\begin{frame}[fragile]{Allocating objects on the heap}
    \begin{itemize}
        \item Objects can be allocated on the heap using the \lstinline{new} keyword \pause
        \item \lstinline{new} gives a pointer to the new instance
    \end{itemize}
    \pause
    \begin{lstlisting}
// To use a parameterless constructor
MyClass* myInstance = new MyClass;

// To use a constructor with parameters
MyClass* myOtherInstance = new MyClass(1, 2, 3);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Deleting objects from the heap}
    \begin{itemize}
        \item Objects instantiated with \lstinline{new} must be deleted using \lstinline{delete} \pause
    \end{itemize}
    \begin{lstlisting}
delete myInstance;
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item Forgetting to do this is a \textbf{memory leak} \pause
        \item Deleting something \textbf{twice} is bad \pause
        \item Trying to \textbf{dereference a deleted pointer} is bad
				\pause\item Key concept is \textbf{ownership}: you're responsible for deleting it \textbf{if and only if} you own it
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Addressing and dereferencing}
    \begin{lstlisting}
int a = 7;

// Address-of operator
int* b = &a;

// Dereferencing
int c = *b;
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item \lstinline{&} gets the \textbf{address} of a variable, i.e.\ a pointer to it
        \item \lstinline{*} \textbf{dereferences} the pointer, i.e.\ looks up the thing it points to
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Socrative \texttt{FALCOMPED}}
    \begin{lstlisting}
int a = 7;
int* b = &a;
int c = *b;
    \end{lstlisting}
    Suppose that the variables are assigned to the following memory addresses:
    \begin{center}
        \begin{tabular}{r|ccc}
            \textbf{Variable} & {\lstinline!a!} & {\lstinline!b!} & {\lstinline!c!} \\ \hline
%            \textbf{Variable} & a & b & c \\
            \textbf{Address} & 1000 & 1004 & 1008
        \end{tabular}
    \end{center}
    \pause
    \begin{enumerate}
        \item What is the value of \lstinline{a}? \pause
        \item What is the value of \lstinline{b}? \pause
        \item What is the value of \lstinline{c}?
    \end{enumerate}
\end{frame}

%\begin{frame}[fragile]{Dereferencing for objects}
    %\begin{itemize}
        %\item This would work...
    %\end{itemize}
    %\begin{lstlisting}
%Circle* myCircle = new Circle(10);
%double area = (*myCircle).getArea();
    %\end{lstlisting}
    %\pause
    %\begin{itemize}
        %\item \lstinline{->} is a shorthand for dereferencing and accessing a member \pause
        %\item The code below is equivalent to the code above, but clearer
    %\end{itemize}
    %\begin{lstlisting}
%Circle* myCircle = new Circle(10);
%double area = myCircle->getArea();
    %\end{lstlisting}
%\end{frame}

\begin{frame}[fragile]{Null pointer}
    \begin{itemize}
        \item Pointers can have a special value \lstinline{nullptr} \pause
        \item This signifies the pointer doesn't point to anything \pause
    \end{itemize}
    \begin{lstlisting}
MyClass* notAnInstance = nullptr;
    \end{lstlisting}
    \pause
    \begin{itemize}
        \item Similar to \lstinline[language=Python]{None} in Python \pause
        \item You may also see \lstinline{NULL} used instead of \lstinline{nullptr} ---
            the meaning is the same
    \end{itemize}
\end{frame}

%\begin{frame}[fragile]{Dangling pointers}
    %\begin{lstlisting}
%delete myInstance;
    %\end{lstlisting}
    %\pause
    %\begin{itemize}
        %\item The instance that \lstinline{myInstance} pointed to has been deleted, but \lstinline{myInstance} still holds its old address \pause
        %\item \lstinline{myInstance} is a \textbf{dangling pointer}, and dereferencing it would certainly be a bug \pause
        %\item Get into the habit of setting pointers to \lstinline{nullptr} after deleting them \pause
        %\begin{itemize}
            %\item Dereferencing a null pointer is still a bug, but will generally crash your program straight away rather than causing obscure errors
        %\end{itemize}
    %\end{itemize}
%\end{frame}

%\begin{frame}[fragile]{Polymorphism}
    %\begin{itemize}
        %\item Can have a pointer to a \textbf{base class} which is actually an instance of a \textbf{derived class}
    %\end{itemize}
    %\begin{lstlisting}
%class Shape { ... };
%class Circle : public Shape { ... };
%
%Shape* myShape = new Circle(10);
%std::cout << myShape.getArea() << std::endl;
    %\end{lstlisting}
%\end{frame}
