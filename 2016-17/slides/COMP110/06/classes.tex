\part{Classes and objects}
\frame{\partpage}

\begin{frame}{A non-object-oriented program}
	Clone the \texttt{bsc-live-coding} repository to your local machine:
	\begin{itemize}
		\item Open an appropriate folder (e.g.\ on the \texttt{X:} drive) and right-click in empty space
		\item Select \textbf{Git Clone...}
		\item For the URL, enter \url{https://github.com/Falmouth-Games-Academy/bsc-live-coding.git}
		\item Click OK
	\end{itemize}
	Once it has finished downloading, open \texttt{bsc-live-coding\textbackslash{}COMP110\textbackslash{}06\_OOP} in PyCharm
\end{frame}

\begin{frame}{What's wrong with this program?}
	\begin{itemize}
		\pause\item Data for a single ``thing'' (a ball) is spread across multiple data structures
		\pause\item It's messy --- we have to type a lot of list indexing expressions
		\pause\item It's inefficient --- all that list indexing takes time
		\pause\item It's error-prone --- if we start inserting or removing elements, the lists can easily get out of step with each other
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{A better approach}
	\begin{itemize}
		\pause\item We can use a \textbf{class} to collect the data for a single ball
		\pause\item A class has \textbf{fields}, each of which is essentially a variable
		\pause\item Syntax:
	\end{itemize}
	\begin{lstlisting}
class Ball:
	def __init__(self):
		self.pos_x = ...
		self.pos_y = ...
	\end{lstlisting}
	\begin{itemize}
		\pause\item We use a class by creating \textbf{instances} of it
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{The constructor}
	\begin{lstlisting}
class Ball:
	def __init__(self):
		self.pos_x = ...
		self.pos_y = ...
	\end{lstlisting}
	\begin{itemize}
		\pause\item The \textbf{constructor} or \textbf{initialiser} is called when an instance of the class is created
		\pause\item Must be named \lstinline{__init__}
			\begin{itemize}
				\pause\item Note the double underscores: \lstinline{_ _ i n i t _ _}
			\end{itemize}
		\pause\item First parameter must be \lstinline{self}, and is the instance being created
		\pause\item Other parameters are optional
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Fields}
	\begin{lstlisting}
class Ball:
	def __init__(self):
		self.pos_x = ...
		self.pos_y = ...
	\end{lstlisting}
	\begin{itemize}
		\pause\item In Python, \textbf{fields} are defined by \textbf{assigning} to them
			\begin{itemize}
				\pause\item Just like ordinary variables
			\end{itemize}
		\pause\item Usually define all fields in \lstinline{__init__}
			\begin{itemize}
				\pause\item It's possible to define new fields after, but for maintainability it is better to collect them all in the same place
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Instantiating}
	\begin{itemize}
		\pause\item To create an instance of a class, call the class as if it was a function:
	\end{itemize}
	\begin{lstlisting}
ball = Ball()
	\end{lstlisting}
	\begin{itemize}
		\pause\item If \lstinline{__init__} takes parameters other than \lstinline{self}, specify them here
		\pause\item To access fields, use \textbf{dot notation}:
	\end{itemize}
	\begin{lstlisting}
ball.pos_x += 10
print ball.pos_x
	\end{lstlisting}
\end{frame}

\begin{frame}{Live coding}
\end{frame}

\begin{frame}[fragile]{Methods}
	\begin{itemize}
		\pause\item As well as \textbf{fields}, classes can also contain \textbf{methods}
		\pause\item A method is simply a \textbf{function} which operates on a particular instance of the class
		\pause\item Syntax is similar to regular Python functions:
	\end{itemize}
	\begin{lstlisting}
class Ball:
	def update(self):
		print "Do something"
	\end{lstlisting}
	\begin{itemize}
		\pause\item Methods take \lstinline{self} as their first parameter, can optionally take other parameters
		\pause\item \lstinline{self} can be used inside the method to access fields
		\pause\item Use dot notation to call methods
	\end{itemize}
\end{frame}

\begin{frame}{Live coding}
\end{frame}

\begin{frame}{Recap of terminology}
	\begin{itemize}
		\pause\item An \textbf{object} is a collection of \textbf{fields} which store data,
			and \textbf{methods} which act on that data
			\begin{itemize}
				\pause\item Fields can also be called \textbf{attributes} or \textbf{member variables}
				\pause\item Methods can also be called \textbf{member functions}
			\end{itemize}
		\pause\item The fields and methods available on an object are determined by its \textbf{class}, i.e.\ its \textbf{type}
		\pause\item A class is a ``blueprint'' for an object; an \textbf{instance} is the object itself
	\end{itemize}
\end{frame}

\begin{frame}{Encapsulation}
	Good OOP design allows for:
	\begin{itemize}
		\pause\item Related code and data definitions to be collected in a single place
		\pause\item Development of modular reusable components
		\pause\item Decoupling of object behaviour from implementation details
	\end{itemize}
\end{frame}

