\begin{frame}{Relationships}
\begin{itemize}
	\pause\item OOP models three types of real-world relationships: \textbf{is a}, \textbf{has a} and \textbf{is a type of}
	\begin{itemize}
		\pause\item Donald \textbf{is a} duck
		\pause\item A duck \textbf{has a} bill
		\pause\item A duck \textbf{is a type of} bird
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Is-a $\to$ Instantiation}
\begin{itemize}
	\pause\item ``X is a Y'' means ``the specific object X is an object of the type Y''
	\pause\item Is-a is modelled by \textbf{classes} and \textbf{instances}:
	\begin{itemize}
		\pause\item ``Donald is a duck'' 
			$\to$ ``\lstinline{donald} is an \textbf{instance} of the \textbf{class} \lstinline{Duck}''
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Has-a $\to$ Composition}
\begin{itemize}
	\pause\item ``X has a Y'' means ``an object of type X \textbf{possesses} an object of type Y''
	\pause\item OOP models this by having a \textbf{field} on X which holds an instance of Y
	\begin{itemize}
		\pause\item ``A duck has a bill''
			$\to$ ``The class \lstinline{Duck} has a \textbf{field} which contains an instance of the class \lstinline{Bill}''
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Is-a-type-of $\to$ Inheritance}
\begin{itemize}
	\pause\item ``X is a type of Y'' means ``If an object is of type X, then it is \textbf{also} of type Y''
	\begin{itemize}
		\pause\item ``A duck is a type of bird'' $\to$ ``If something is a duck, then it is also a bird''
		\pause\item ``Every duck is a bird''
		\pause\item ``If something is true for all birds, then it must be true for ducks''
	\end{itemize}
	\pause\item In OOP terms, this is called \textbf{inheritance}
\end{itemize}
\end{frame}

\begin{frame}{Inheritance}
\begin{itemize}
	\pause\item Recall: an \textbf{object} is a collection of \textbf{fields} (data) and \textbf{methods} (code)
	\pause\item Recall: the \textbf{class} defines which fields and methods an object possesses
	\pause\item ``X is a type of Y'' $\to$ class \lstinline{X} inherits from class \lstinline{Y}
	\pause\item Class X inherits all of the fields and methods from class Y, as well as any fields and methods of its own
\end{itemize}
\end{frame}

\begin{frame}{When to inherit?}
\begin{itemize}
	\pause\item When modelling an \textbf{is-a-type-of} relationship from the real world
	\pause\item When several classes can \textbf{share} some fields and/or methods
	\begin{itemize}
		\pause\item I.e. to minimise \textbf{code duplication}
	\end{itemize}
	\pause\item When several classes should have methods with the \textbf{same names}, but which do \textbf{different things}
	\begin{itemize}
		\pause\item This is called \textbf{polymorphism} --- more on this later
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Inheritance in Python}
\end{frame}

\begin{frame}{Inheritance in Python}
\end{frame}

\begin{frame}{Inheritance in Python}
\end{frame}

\begin{frame}{Inheritance in Python}
\end{frame}

\begin{frame}{Inheritance in Python}
\end{frame}

\begin{frame}{Chains of inheritance}
\begin{itemize}
	\pause\item ``A mallard is a type of duck, which is a type of bird, which is a type of vertebrate, which is a type of animal...''
	\pause\item Is-a-type-of is \textbf{transitive}
	\begin{itemize}
		\pause\item If A is-a-type-of B and B is-a-type-of C, then A is-a-type-of C
	\end{itemize}
	\pause\item Likewise: class A inherits from class B, which inherits from class C, ...
	\begin{itemize}
		\pause\item ``Inherits from'' is also transitive
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{A possible inheritance hierarchy}
\end{frame}

\begin{frame}{OOP: Polymorphism}
\end{frame}

\begin{frame}{Polymorphism}
\begin{itemize}
	\pause\item From Greek: ``many-shape-ism''
	\pause\item Different classes can have the \textbf{same public interface}
	\pause\item Thus we can write code that \textbf{uses} this interface, but doesn't need to worry about the \textbf{implementation} behind it
\end{itemize}
\end{frame}

\begin{frame}{Method overriding}
\begin{itemize}
	\pause\item A class can \textbf{override} methods defined in the class from which it inherits
	\pause\item The overridden method can call the method from the base class, but it doesn't have to
\end{itemize}
\end{frame}

\begin{frame}{Without polymorphism}
\begin{itemize}
	\pause\item We have a list of shapes, and want to draw them all
	\pause\item This approach is messy and difficult to maintain
\end{itemize}
\end{frame}

\begin{frame}{Polymorphism to the rescue!}
\begin{itemize}
	\pause\item All subclasses of \lstinline{Shape} implement \lstinline{draw}
	\pause\item We can call \lstinline{shape->draw()} without worrying which type of shape it is
\end{itemize}
\end{frame}

\begin{frame}{Abstract classes and methods}
\begin{itemize}
	\pause\item Some classes should never be instantiated directly, as they only exist to be inherited from
	\begin{itemize}
		\pause\item \lstinline{Shape} is an example
	\end{itemize}
	\pause\item Such classes are called \textbf{abstract}
	\pause\item Abstract methods are methods of an abstract class which are left unimplemented, so \textbf{must} be implemented in subclasses
	\begin{itemize}
		\pause\item \lstinline{draw} is an example
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{OOP: Access control}
\end{frame}

\begin{frame}{Access control}
\begin{itemize}
	\pause\item For \textbf{encapsulation}, it is a good idea to restrict access to certain attributes and methods from outside the class
	\pause\item \textbf{Private} members are only accessible from the class's \textbf{own} methods
	\pause\item \textbf{Protected} members are accessible from the class's own methods, \textbf{and} methods defined in \textbf{subclasses}
	\pause\item \textbf{Public} members are accessible from \textbf{outside} the class
\end{itemize}
\end{frame}

\begin{frame}{Access control}
\begin{itemize}
	\pause\item The \textbf{public interface} of an object is how it interacts with other objects and the rest of the program
	\pause\item The \textbf{protected interface} of an object is what allows subclasses to change the way the base class behaves
	\pause\item The \textbf{private members} of an object are implementation details, hidden from the outside world
\end{itemize}
\end{frame}

%\begin{frame}{Access control in Python}
%\begin{itemize}
%	\pause\item A field or method whose name begins with _ is protected
%	\pause\item A field or method whose name begins with _ _ is private
%	\begin{itemize}
%		\pause\item Names which begin and end with _ _ (like __init__) are special --- don't use trailing underscores in your own names
%	\end{itemize}
%	\pause\item Everything else is public
%\end{itemize}
%\end{frame}

\begin{frame}{Pedantic detail}
\begin{itemize}
	\pause\item Access control is merely a \textbf{convention} in Python
	\begin{itemize}
		\pause\item The interpreter \textbf{won't stop} you from accessing protected members from outside the class or its subclasses, but PyCharm will \textbf{warn} you
		\pause\item Private members are ``name mangled'', but you can still access them if you know how
	\end{itemize}
	\pause\item Almost all other languages enforce access control with compile-time errors
\end{itemize}
\end{frame}

\begin{frame}{Summary}
\begin{itemize}
	\pause\item OOP models three main types of real-world relationships
	\begin{itemize}
		\pause\item Is-a $\to$ instantiation
		\pause\item Has-a $\to$ composition
		\pause\item Is-a-type-of $\to$ inheritance
	\end{itemize}
	\pause\item Inheritance allows polymorphism: different classes with the same public interface
	\pause\item Access control is an important tool in designing reusable, encapsulated objects
\end{itemize}
\end{frame}
