\part{Linked lists}
\frame{\partpage}

\begin{frame}{Linked list}
	\begin{itemize}
		\pause\item Composed of a number of \textbf{nodes}
		\pause\item Each node contains:
			\begin{itemize}
		 		\pause\item An \textbf{item} --- the actual data to be stored
		 		\pause\item A pointer or reference to the \textbf{previous node} in the list (null for the first item)
		 		\pause\item A pointer or reference to the \textbf{next node} in the list (null for the last item)
			\end{itemize}
		\pause\item The nodes are \textbf{not necessarily contiguous} in memory, unlike an (array-backed) list
	\end{itemize}
	\pause
	\vspace{2ex}
	\begin{center}
	    \setlength{\tabcolsep}{0.2em}
		\begin{tabular}{|c|c|c|}
			\hline
			{\tiny prev} & {\tiny item} & {\tiny next} \\
			$\times$ & \texttt{\footnotesize first} & \tikzmark{nexta} \\\hline
		\end{tabular}
		\qquad
		\begin{tabular}{|c|c|c|}
			\hline
			{\tiny prev} & {\tiny item} & {\tiny next} \\
			\tikzmark{prevb} & \texttt{\footnotesize second} & \tikzmark{nextb} \\\hline
		\end{tabular}
		\qquad
		\begin{tabular}{|c|c|c|}
			\hline
			{\tiny prev} & {\tiny item} & {\tiny next} \\
			\tikzmark{prevc} & \texttt{\footnotesize third} & $\times$ \\\hline
		\end{tabular}
		\begin{tikzpicture}
			[
			  remember picture,
			  overlay,
			  -latex,
			  yshift=0.5ex,
			  shorten >=1pt,
			  shorten <=1pt,
			]
			\draw ($ ({pic cs:nexta}) + (0, 0.5ex) $) to ($ ({pic cs:prevb}) + (-1.2ex, 0.5ex) $);
			\draw ($ ({pic cs:nextb}) + (0, 0.5ex) $) to ($ ({pic cs:prevc}) + (-1.2ex, 0.5ex) $);
			\draw ($ ({pic cs:prevb}) + (0, -0.5ex) $) to ($ ({pic cs:nexta}) + (1.2ex, -0.5ex) $);
			\draw ($ ({pic cs:prevc}) + (0, -0.5ex) $) to ($ ({pic cs:nextb}) + (1.2ex, -0.5ex) $);
		\end{tikzpicture}
	\end{center}
	\begin{itemize}
		\pause\item In C\#: \lstinline{LinkedList<ElementType>}
	\end{itemize}
\end{frame}

\begin{frame}{Operations on linked lists}
\end{frame}

\newcommand{\footnoteref}[1]{$^{\text{\ref{#1}}}$}

\begin{frame}{Linked lists vs array-backed lists}
	\begin{itemize}
		\pause\item \textbf{Inserting} and \textbf{removing} from the middle of an array list requires shuffling the following elements to make or fill space
		\pause\item This makes these operations $O(n)$
		\pause\item Linked list doesn't require this shuffling, so inserting and deleting is $O(1)$
		\pause\item However...
		\pause\item \textbf{Finding the $i$th element} of an array list is simple pointer arithmetic, which is $O(1)$
		\pause\item In a linked list we have to count along the ``next'' pointers, which is $O(i)$
		\pause\item So which data structure is more efficient? It depends what operations we need to do more often
	\end{itemize}
\end{frame}
