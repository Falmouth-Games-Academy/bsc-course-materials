\part{Data representation}
\frame{\partpage}

\begin{frame}{Memory}
	\pause
	\begin{center}
		\includegraphics[width=0.8\textwidth]{memory}
	\end{center}
	\begin{itemize}
		\item Memory works like a set of \textbf{boxes}
		\pause\item Each box has a number, its \textbf{address}
		\pause\item Each box contains a \textbf{byte} (8 bits)
	\end{itemize}
\end{frame}

\begin{frame}{Data representation} 
	\begin{itemize}
		\pause\item All data is stored as \textbf{sequences of bytes}
			\begin{itemize}
				\pause\item Sequence of bits, in multiples of 8
				\pause\item Sequence of numbers between 0--255
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Number bases}
	\begin{itemize}
		\pause\item Decimal = base 10
		\pause\item Binary = base 2
		\pause\item Octal = base 8
		\pause\item Hexadecimal = base 16
			\begin{itemize}
				\pause\item Uses \texttt{A}--\texttt{F} as extra ``digits''
			\end{itemize}
		\pause\item We sometimes write the base as a \textbf{subscript}
			\begin{itemize}
				\pause\item $123_{10} = 7B_{16} = 173_{8} = 01111011_{2}$
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Number bases in code}
	\begin{itemize}
		\pause\item In most languages (including C, C++, C\#, Python):
			\begin{itemize}
				\pause\item Decimal: \texttt{123}
				\pause\item Binary: \texttt{0b1111011}
				\pause\item Hexadecimal: \texttt{0x7B}
			\end{itemize}
		\pause\item In some languages (including C, C++, Python 2.x):
			\begin{itemize}
				\pause\item Octal: \texttt{0173}
			\end{itemize}
		\pause\item So beware of leading zeroes!
	\end{itemize}
	\begin{lstlisting}
>>> print 77
77
>>> print 077
63
	\end{lstlisting}
\end{frame}

\begin{frame}{Why is hexadecimal useful?} 
	\begin{itemize}
		\pause\item It is easy to convert between binary and hexadecimal
		\pause\item One hex digit = 4 bits
	\end{itemize}
	
	\pause $$
	\underbrace{0001}_{1}
	\underbrace{1110}_{E}
	\underbrace{0010}_{2}
	\underbrace{0100}_{4}
	\underbrace{0000}_{0}
	$$
	
	\pause So $1\,1110\,0010\,0100\,0000_{2} = 1E240_{16}$
\end{frame}

{
\setbeamercolor{background canvas}{bg=white}
\begin{frame}[plain]
	\begin{tikzpicture}[remember picture, overlay]
		\node[at=(current page.center)] {
			\includegraphics[width=\paperwidth]{ascii_chart}
		};
	\end{tikzpicture}
\end{frame}
}

\begin{frame}{Integers} 
	\begin{itemize}
		\pause\item Represented in \textbf{binary}
		\pause\item \textbf{Unsigned} integers:
			\begin{itemize}
				\pause\item $n$ bits $\implies$ numbers from $0$ to $2^n-1$ inclusive
			\end{itemize}
		\pause\item \textbf{Signed} integers:
			\begin{itemize}
				\pause\item Store negative number $-a$ as $2^n - a$
				\pause\item \textbf{2's complement}
				\pause\item $n$ bits $\implies$ numbers from $-2^{n-1}$ to $2^{n-1}-1$ inclusive
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{2's complement uses modular arithmetic} 
	\begin{center}
		\begin{tikzpicture}[line cap=rect,line width=3pt]
			\filldraw [fill=cyan] (0,0) circle [radius=2cm];
			\foreach \angle [count=\xi from 0] in {90,67.5,...,-247.5}
			{
				\draw[line width=1pt] (\angle:1.8cm) -- (\angle:2.2cm);
				\node[font=\large] at (\angle:1.36cm) {\textsf{\xi}};
			}
			\foreach \angle [count=\xi from -8] in {270,247.5,...,-67.5}
			{
				\node[font=\large] at (\angle:2.56cm) {\textsf{\xi}};
			}
			\foreach \angle in {0,90,180,270}
				\draw[line width=2pt] (\angle:1.6cm) -- (\angle:2cm);
			\draw (0,0) -- (120:0.8cm);
			\draw (0,0) -- (90:1cm);
		\end{tikzpicture}
	\end{center}
\end{frame}

\begin{frame}{Endian-ness}
	\begin{itemize}
		\pause\item Intel x86/x64 architecture is \textbf{little endian}
		\pause\item Bytes are in ``reverse'' order (least significant first)
		\pause\item E.g.\ $123456_{10} = 1E240_{16}$, represented as
			\texttt{40 E2 01 00}
	\end{itemize}
\end{frame}

\begin{frame}{Fractional numbers}
	\begin{itemize}
		\pause\item Generally stored using \textbf{floating point}
		\pause\item More on this another time
	\end{itemize}
\end{frame}

\begin{frame}{Strings}
	\begin{itemize}
		\pause\item Stored as sequences of \textbf{characters} encoded as \textbf{integers}
		\pause\item Often \textbf{null-terminated}
			\begin{itemize}
				\pause\item Zero character signifies the end of the string
			\end{itemize}
		\pause\item \textbf{ASCII} encodes characters as 8-bit integers
			\begin{itemize}
				\pause\item 255 characters: Latin alphabet, numerals, punctuation
			\end{itemize}
		\pause\item \textbf{UTF-32} encodes characters as 32-bit integers
			\begin{itemize}
				\pause\item \textbf{Unicode} characters: ASCII + several other alphabets, Asian languages, symbols, emoji, ...
			\end{itemize}
		\pause\item \textbf{UTF-8} encodes characters as 8, 16, 24 or 32-bit integers
			\begin{itemize}
				\pause\item More common Unicode characters are smaller $\implies$ more efficient than UTF-32
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Object data}
	\begin{itemize}
		\pause\item Fields are fixed size
		\pause\item Stored consecutively in memory
		\pause\item Variable-size data may be stored indirectly, using pointers
	\end{itemize}
\end{frame}

