\part{Algorithm strategies}
\frame{\partpage}

\newcommand{\weight}{\operatorname{weight}}
\newcommand{\val}{\operatorname{value}}
\newcommand{\best}{{\text{best}}}

\begin{frame}{The knapsack problem --- informally}
	\begin{itemize}
		\pause\item You are looting a dungeon in an RPG
		\pause\item Every item you can pick up has a \textbf{weight} and a \textbf{value}
		\pause\item You have a \textbf{maximum carry weight}
		\pause\item Which items should you pick up to maximise the total value without exceeding your carry weight?
	\end{itemize}
\end{frame}

\begin{frame}{The knapsack problem --- formally}
	\begin{itemize}
		\pause\item There is a set $X$ of \textbf{items}
		\pause\item Each item $x$ has a weight $\weight(x)$ and a value $\val(x)$
		\pause\item There is a maximum weight $W$
		\pause\item What subset $S \subseteq X$ maximises the total value, whilst not exceeding the maximum weight?
		\pause\item In other words: find $S \subseteq X$ to maximise
			$$ \sum_{x \in S} \val(x) $$
		subject to
			$$ \sum_{x \in S} \weight(x) \leq W $$
	\end{itemize}
\end{frame}

\begin{frame}{Algorithm strategies}
	\begin{itemize}
		\pause\item Brute force
		\pause\item Greedy
		\pause\item Divide-and-conquer
		\pause\item Dynamic programming
	\end{itemize}
\end{frame}

\begin{frame}{Brute force}
	\begin{itemize}
		\pause\item Try \textbf{every possible} solution and decide which is best
	\end{itemize}
	\pause
	\begin{algorithmic}
		\Procedure{Knapsack}{X, W} \pause
			\State $S_\best \gets \{ \}$
			\State $v_\best \gets 0$ \pause
			\For{every subset $S \subseteq X$} \pause
				\If{$\weight(S) \leq W$ and $\val(S) > v_\best$} \pause
					\State $S_\best \gets S$
					\State $v_\best \gets \val(S)$
				\EndIf \pause
			\EndFor
			\State \textbf{return} $S_\best$
		\EndProcedure
	\end{algorithmic}
\end{frame}

\begin{frame}{Socrative \texttt{FALCOMPED}}
	\begin{itemize}
		\pause\item If $X$ contains $n$ elements, how many subsets of $X$ are there?
		\begin{itemize}
			\item Hint: think about constructing a subset as a series of ``yes or no'' questions
		\end{itemize}
		\pause\item Therefore what is the time complexity of the brute force algorithm?
		\pause\item If we add one element to $X$, what happens to the running time of the algorithm?
	\end{itemize}
\end{frame}

\begin{frame}{Greedy algorithm}
	\begin{itemize}
		\pause\item At each stage of building a solution, take the \textbf{best} available option
	\end{itemize}
	\pause
	\begin{algorithmic}
		\Procedure{Knapsack}{X, W}
			\State $S \gets \{ \}$ \pause
			\For{each $x \in X$, in descending order of $\val(x)$} \pause
				\If{$\weight(S) + \weight(x) \leq W$} \pause
					\State add $x$ to $S$
				\EndIf \pause
			\EndFor
			\State \textbf{return} $S$
		\EndProcedure
	\end{algorithmic}
\end{frame}

\begin{frame}{Greedy algorithm}
	\begin{itemize}
		\pause\item Time complexity is dominated by sorting $X$ by value
		\pause\item The rest of the algorithm runs in linear time
		\pause\item In some problems an appropriately chosen greedy solution is \textbf{optimal}
			\begin{itemize}
				\pause\item A$^*$ pathfinding
				\pause\item Huffman coding
			\end{itemize}
		\pause\item \textbf{However} the greedy solution to the knapsack problem may not be optimal!
		\pause\item For example (maximum carry weight is $100$)
		\begin{itemize}
			\pause\item Greedy algorithm takes 1 set of horse armour (weight 100, value 500)
			\pause\item ... instead of 100 silver coins (each weight 1, value 10)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Divide and conquer strategies}
	\begin{itemize}
		\pause\item Break the problem into smaller, easier to solve \textbf{subproblems}
		\pause\item Requires that the solution to the original problem is composed of the solutions to the smaller problem
		\pause\item Example from earlier in the module: \textbf{binary search}
			\begin{itemize}
				\pause\item Problem: find an element in a list
				\pause\item Subproblem: find the element in a list of half the size
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Divide and conquer for the knapsack problem}
	\begin{itemize}
		\pause\item Consider an element $x \in X$ with $\weight(x) \leq W$
		\pause\item Let $X'$ be $X$ with $x$ removed
		\pause\item The solution to the knapsack problem either includes $x$ or it doesn't
		\pause\item The solution is \textbf{either}:
			\begin{itemize}
				\pause\item The solution to the knapsack problem on $X'$ with maximum weight $W$, \textbf{or}
				\pause\item The solution to the knapsack problem on $X'$ with maximum weight $W - \weight(x)$,
					plus $x$
			\end{itemize}
		\pause\item ... whichever has the greater value
		\pause\item Base case: the solution to the knapsack problem on the empty set \textbf{is} the empty set
	\end{itemize}
\end{frame}

\begin{frame}{In other words...}
	\begin{itemize}
		\pause\item Think about solving the knapsack problem based on the remaining loot and the remaining carry capacity
		\pause\item Base case: if you have no carry capacity left, there is nothing to loot
		\pause\item For each piece of loot, try:
		\begin{itemize}
			\pause\item Picking it up and solving the problem with the resulting (reduced) carry capacity
			\pause\item Leaving it and solving the problem with the original carry capacity
		\end{itemize}
		\pause\item Whichever of those two gives the best result, go with it
	\end{itemize}
\end{frame}

\begin{frame}{Divide and conquer for the knapsack problem}
	\begin{algorithmic}
		\Procedure{Knapsack}{X, W} \pause
			\If{$X = \{\}$ or $W \leq 0$}
				\State \textbf{return} $\{\}$
			\EndIf \pause

			\State $x \gets \text{last element of $X$}$ \pause
			\State $X' \gets X \text{ without } x$ \pause
			\State $S \gets \Call{Knapsack}{X', W}$ \pause
			\If{$\weight(x) \leq W$} \pause
				\State $S' \gets \Call{Knapsack}{X', W - \weight(x)}$
				\State add $x_k$ to $S'$ \pause
				\State \textbf{return} whichever of $S,S'$ has the larger value \pause
			\Else
				\State \textbf{return} $S$
			\EndIf
		\EndProcedure
	\end{algorithmic}
\end{frame}

\begin{frame}{Time complexity}
	\begin{itemize}
		\pause\item Each call to \Call{Knapsack}{} has, in the worst case, \textbf{two} recursive calls to \Call{Knapsack}{}
		\pause\item Number of calls is
			$$ \underbrace{1 + 2 + 4 + 8 + \dots + 2^i + \dots}_{\text{$n$ terms}} $$
		\pause\item Thus the worst case time complexity is $O(2^n)$ --- still exponential!
		\pause\item However in the \textbf{average} case many of the calls have only a single recursive call,
			so this is still more efficient than brute force
	\end{itemize}
\end{frame}

\begin{frame}{Overlapping subproblems}
	\begin{itemize}
		\pause\item Here we end up solving the \textbf{same subproblem multiple times}
		\pause\item Can save time by \textbf{caching} (remembering) these sub-solutions
		\pause\item This is called \textbf{memoization}
			\begin{itemize}
				\pause\item \textbf{Not} memo\underline{r}ization!
			\end{itemize}
		\pause\item One of several techniques in the category of \textbf{dynamic programming}
	\end{itemize}
\end{frame}

\begin{frame}{Dynamic programming for the knapsack problem}
    \footnotesize
	\begin{algorithmic}
		\Procedure{Knapsack}{X, W}
			\If{\Call{Knapsack}{X, W} has already been computed} \pause
				\State \textbf{return} previously computed result
			\EndIf \pause
			
			\If{$X = \{\}$ or $W \leq 0$}
				\State \textbf{return} $\{\}$
			\EndIf 

			\State $x \gets \text{last element of $X$}$ 
			\State $X' \gets X \text{ without } x$ 
			\State $S \gets \Call{Knapsack}{X', W}$ 
			\If{$\weight(x) \leq W$} 
				\State $S' \gets \Call{Knapsack}{X', W - \weight(x)}$
				\State add $x_k$ to $S'$ 
				\State \textbf{cache and return} whichever of $S,S'$ has the larger value
			\Else
				\State \textbf{cache and return} $S$
			\EndIf
		\EndProcedure
	\end{algorithmic}
\end{frame}

\begin{frame}{Time complexity}
	\begin{itemize}
		\pause\item The running time of a dynamic programming algorithm is limited by the size of the result table --- once the table is filled, there is nothing left to do
		\pause\item In this case, combinations of $X$ and $W$
		\pause\item If we always remove the last element of $X$, then there are $n+1$ possibilities
		\pause\item Remaining carry weight is an integer between 0 and $W$ --- so there are $W+1$ possibilities
	\end{itemize}
	\pause\begin{center}Socrative \texttt{FALCOMPED}\end{center}
	\begin{itemize}
		\item What is the maximum possible number of entries in the table of intermediate results?
		\pause\item Therefore what is the time complexity of the dynamic programming algorithm?
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Another example of dynamic programming}
    \begin{itemize}
        \pause\item From the beginning of the lecture:
    \end{itemize}
    \begin{lstlisting}
int fibonacci(int n)
{
    if (n <= 2)
        return 1;
    else
        return fibonacci(n-1) + fibonacci(n-2);
}
    \end{lstlisting}
    \begin{itemize}
        \pause\item \lstinline{fibonacci(10)} calls \lstinline{fibonacci(9)} and \lstinline{fibonacci(8)}
        \pause\item \lstinline{fibonacci(9)} calls \lstinline{fibonacci(8)} and \lstinline{fibonacci(7)}
        \pause\item \lstinline{fibonacci(8)} calls \lstinline{fibonacci(7)} and \lstinline{fibonacci(6)}
        \pause\item So if we memoize, we can vastly reduce the number of recursive calls
    \end{itemize}
\end{frame}

\begin{frame}{Summary of algorithm strategies}
	\begin{itemize}
		\pause\item Brute force
			\begin{itemize}
				\pause\item Good enough for small/simple problems
			\end{itemize}
		\pause\item Greedy
			\begin{itemize}
				\pause\item Efficient for certain problems, but doesn't always give optimal solutions
			\end{itemize}
		\pause\item Divide-and-conquer
			\begin{itemize}
				\pause\item Good if the problem can be broken down into simpler subproblems
			\end{itemize}
		\pause\item Dynamic programming
			\begin{itemize}
				\pause\item Makes divide-and-conquer more efficient if subproblems often reoccur
			\end{itemize}
	\end{itemize}
\end{frame}

