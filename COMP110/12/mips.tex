\part{The MIPS architecture}
\frame{\partpage}

\begin{frame}{MIPS}
	\begin{itemize}
		\pause\item An example of a \textbf{Reduced Instruction Set Computer (RISC)} architecture
			\begin{itemize}
				\pause\item Small number of simple instructions --- computational power comes from executing
					many instructions per second
				\pause\item Compare with \textbf{Complex Instruction Set Computer (CISC)} architecture (e.g.\ Intel x86)
					--- large number of complex instructions
					--- fewer instructions per second, but shorter programs
			\end{itemize}
		\pause\item MIPS was popular in 1980s -- 2000s
			\begin{itemize}
				\pause\item Embedded systems
				\pause\item Consoles (Nintendo 64, PlayStation 1 and 2)
			\end{itemize}
		\pause\item Easier to understand than most CPU instruction sets in common use today
	\end{itemize}
\end{frame}

\begin{frame}{Online MIPS simulator}
	\begin{center}
		\url{http://rivoire.cs.sonoma.edu/cs351/wemips/}
	\end{center}
\end{frame}

\begin{frame}{Registers}
	\begin{itemize}
		\pause\item Memory locations inside the CPU
		\pause\item Faster to access than main memory
		\pause\item Registers in MIPS architecture include:
			\begin{itemize}
				\pause\item \lstinline{$zero}: constant 0
				\pause\item \lstinline{$t0}--\lstinline{$t9}: temporary storage
				\pause\item \lstinline{$s0}--\lstinline{$s7}: saved temporary storage
				%\pause\item \lstinline{$a0}--\lstinline{$a3}: function arguments
				%\pause\item \lstinline{$v0}--\lstinline{$v1}: function return values
			\end{itemize}
		\pause\item Each register holds a single 32-bit value
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Adding register values}
	\pause
	\begin{lstlisting}
add $d, $s, $t
	\end{lstlisting}
	\begin{itemize}
		\pause\item \lstinline{$d}, \lstinline{$s} and \lstinline{$t} are register names
		\pause\item This adds the value of \lstinline{$s} to the value of \lstinline{$t},
			and stores the result in \lstinline{$d}
	\end{itemize}
	\pause
	\begin{lstlisting}
sub $d, $s, $t
	\end{lstlisting}
	\begin{itemize}
		\pause\item Subtracts the value of \lstinline{$t} from the value of \lstinline{$s},
			and stores the result in \lstinline{$d}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Adding a constant}
	\pause
	\begin{lstlisting}
addi $d, $s, C
	\end{lstlisting}
	\begin{itemize}
		\pause\item \lstinline{$d} and \lstinline{$s} are register names, \lstinline{C} is an integer constant
		\pause\item This adds the value of \lstinline{$s} to \lstinline{C},
			and stores the result in \lstinline{$d}
		\pause\item \lstinline{addi} = ``add immediate''
			--- as in \lstinline{C} is specified immediately in the code, not looked up from a register
		\pause\item There is no \lstinline{subi} instruction --- to subtract \lstinline{C},
			add \lstinline{-C}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{More fun with addi}
	\begin{itemize}
		\pause\item Socrative \texttt{FALCOMPED}
		\pause\item What does this code do?
	\end{itemize}
	\begin{lstlisting}
addi $s0, $s1, 0
	\end{lstlisting}
	\begin{itemize}
		\pause\item What does this code do?
	\end{itemize}
	\begin{lstlisting}
addi $s0, $zero, 12
	\end{lstlisting}
	\begin{itemize}
		\pause\item MIPS does not have dedicated instructions for setting a register value to a
			constant or to the value of another register --- it has to be done with \lstinline{addi}
	\end{itemize}
\end{frame}
