\part{Floating point numbers}
\frame{\partpage}

\begin{frame}{Floating point numbers}
	\begin{itemize}
		\pause\item Similar to scientific notation, but \textbf{base 2} (binary)
		\pause\item $a \times 10^b$, where
			\begin{itemize}
				\pause\item $a$ ($1 \leq |a| < 2$) is the \textbf{mantissa}
				\pause\item ($a$ is a positive or negative number
					with a single $1$ before the ``decimal point'')
				\pause\item $b$ (an integer) is the \textbf{exponent}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Storing the mantissa}
	\begin{itemize}
		\pause\item A positive or negative number with a single $1$ before the ``decimal point''
		\pause\item Sign is stored as a single bit: $0=+$, $1=-$
		\pause\item We know there's a $1$ before the point so no need to store it --- just store the binary
			digits after the point
	\end{itemize}
\end{frame}

\begin{frame}{Storing the exponent}
	\begin{itemize}
		\pause\item An integer --- can be positive, negative or zero
		\pause\item NB we don't use 2's complement to store it!
		\pause\item Instead it is stored in binary as a positive integer with a \textbf{bias} added on
		\pause\item (This is so that exponents can be efficiently compared (less/greater than)
			--- 2's complement would be less efficient for this)
	\end{itemize}
\end{frame}

\begin{frame}{Exponent bias}
	\begin{itemize}
		\pause\item E.g.\ if the bias is $127$:
	\end{itemize}
	\pause
	\begin{center}
		\begin{tabular}{|r|l|}
			\hline
			An exponent of... & ... is stored as \\\hline
			-126 & 00000001 (1) \\
			\vdots & \vdots \\
			-1 & 01111110 (126) \\
			0 & 01111111 (127) \\
			1 & 10000000 (128) \\
			\vdots & \vdots \\
			127 & 11111110 (254) \\\hline
		\end{tabular}
	\end{center}
	\begin{itemize}
		\pause\item (Exponents of 00000000 and 11111111 have special meaning --- more on this later)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{IEEE 754 floating point formats}
	\begin{center}
		\begin{tabular}{|r|ccc|l|}
			\hline
			Type & Sign & Exponent & Mantissa & Total \\\hline
			Single precision & 1 bit & 8 bits & 23 bits & 32 bits \\
			&& bias 127 && \\\hline
			Double precision & 1 bit & 11 bits & 52 bits & 64 bits \\
			&& bias 1023 && \\\hline
			Extended precision & 1 bit & 15 bits & 64 bits & 80 bits \\
			&& bias 16383 && \\\hline
		\end{tabular}
	\end{center}
\end{frame}

\begin{frame}[fragile]{IEEE 754 floating point formats}
	\begin{itemize}
		\pause\item C\# (and many other languages) have \lstinline{float} and \lstinline{double} types
			for single and double precision respectively
		\pause\item Literals are interpreted as \lstinline{float} if they end in \lstinline{f}, otherwise \lstinline{double}
			\begin{itemize}
				\pause\item \lstinline{3.14f} is a \lstinline{float}
				\pause\item \lstinline{3.14} is a \lstinline{double}
			\end{itemize}
		\pause\item Python's \lstinline{float} type is double precision as standard
		\pause\item Extended precision is not usually used in programs, but is used internally on Intel CPUs
	\end{itemize}
\end{frame}

\begin{frame}{Example}
	\pause
	What is the value stored in the following IEEE single-precision floating point number?
	\begin{center}
		\texttt{01000000110100000000000000000000}
	\end{center}
\end{frame}

\begin{frame}{Example}
	\pause
	\begin{center}
		\texttt{\fbox{0}1000000110100000000000000000000}
	\end{center}
	\begin{itemize}
		\pause\item Sign bit is 0
		\pause\item Therefore the number is positive
	\end{itemize}
\end{frame}

\begin{frame}{Example}
	\pause
	\begin{center}
		\texttt{0\fbox{10000001}10100000000000000000000}
	\end{center}
	\begin{itemize}
		\pause\item Exponent is 10000001
		\pause\item This is 129 in binary
		\pause\item Exponent is stored with a bias of 127, therefore the actual exponent is
			$129 - 127 = 2$
	\end{itemize}
\end{frame}

\begin{frame}{Example}
	\pause
	\begin{center}
		\texttt{010000001\fbox{10100000000000000000000}}
	\end{center}
	\begin{itemize}
		\pause\item Mantissa is $101000\dots$
		\pause\item Remember we only store the digits after the ``decimal point'', so the mantissa
			is actually $1.101000\dots$
		\pause\item The exponent is 2, so we move the point 2 places to the right:
			$110.1000\dots$
		\pause\item $4 + 2 + \frac12 = 6.5$
	\end{itemize}
\end{frame}

%\begin{frame}{Socrative \texttt{FALCOMPED}}
	%\pause
	%What is the value of this number expressed in IEEE 754 single precision format?
	%\begin{center}
		%\texttt{0 10000010 01011000000000000000000}
	%\end{center}
	%You have \textbf{5 minutes}, and you \textbf{may} use a calculator!
	%(Unless your calculator does IEEE 754 conversion...)
%\end{frame}
%
%\iftoggle{printable}{}{
%\begin{frame}{Example}
	%\pause
	%\begin{center}
		%\texttt{0 10000010 01011000000000000000000}
	%\end{center}
	%\begin{itemize}
		%\pause\item Exponent: $130 - 127 = 3$
		%\pause\item Mantissa: binary $1.01011$
		%\pause\item $1 + \frac14 + \frac{1}{16} + \frac{1}{32} = 1.34375$
		%\pause\item $1.34375 \times 2^3 = 10.75$
		%\pause\item Alternatively: $1.01011 \times 2^3 = 1010.11$
		%\pause\item $= 8 + 2 + \frac12 + \frac14 = 10.75$
	%\end{itemize}
%\end{frame}
%}

\begin{frame}[fragile]{Special floating point numbers}
	\begin{itemize}
		\pause\item Zero is represented by a mantissa and exponent of all 0s
		\pause\item An exponent of all 1s is used to represent infinity or NaN
			\begin{itemize}
				\pause\item \lstinline{float.PositiveInfinity} or \lstinline{double.PositiveInfinity}:
					a number which is greater than every other number
				\pause\item \lstinline{float.NegativeInfinity} or \lstinline{double.NegativeInfinity}:
					a number which is less than every other number
				\pause\item \lstinline{float.NaN} or \lstinline{double.NaN}:
					``Not A Number'' --- \lstinline{<}, \lstinline{>}, \lstinline{==}
					always return \lstinline{false}
			\end{itemize}
		\pause\item Can check for these with \lstinline{float.IsInfinity},
			\lstinline{double.IsNaN}, etc.
		\pause\item Infinities and NaNs sometimes arise from calculations (e.g.\ dividing by zero)
	\end{itemize}
\end{frame}
