\part{Numeric types}
\frame{\partpage}

\begin{frame}{Integers}
	\begin{itemize}
		\pause\item An \textbf{integer} is a whole number --- positive, negative or zero
		\pause\item Python type: \lstinline{int}
		\pause\item In most languages, \lstinline{int} is limited to 32 or 64 bits
		\pause\item Python uses \textbf{big integers} --- number of bits expands automatically to fit the value to be stored
		\pause\item Stored in memory using binary notation, with 2's complement for negative values
	\end{itemize}
\end{frame}

% \begin{frame}{Integers as bytes}
% 	\begin{itemize}
% 		\pause\item A \textbf{32-bit} integer is stored as a sequence of \textbf{4 bytes}
% 		\pause\item Example: 314159 in decimal = $100\,11001011\,00101111$ in binary
% 		\pause\item Stored as four bytes:
% 		    $$
% 		        00000000 \quad
% 		        00000100 \quad
% 		        11001011 \quad
% 		        00101111
%             $$
%             or in hexadecimal:
%             $$
% 		        00 \quad
% 		        04 \quad
% 		        CB \quad
% 		        2F
% 		    $$
% 		\pause\item Similarly for other sizes of integer:
% 		    an $n$-bit integer is stored as $n \div 8$ bytes
% 		\pause\item You can think of this as a base-256 numbering system
% 	\end{itemize}
% \end{frame}

% \begin{frame}{Endianness}
% 	\begin{itemize}
% 		\pause\item Integers are stored either \textbf{big endian} or \textbf{little endian}
% 		\pause\item Big endian: the \textbf{most significant byte} comes first
%             $$
% 		        00 \quad
% 		        04 \quad
% 		        CB \quad
% 		        2F
% 		    $$
% 		\pause\item Little endian: the \textbf{least significant byte} comes first
%             $$
% 		        2F \quad
% 		        CB \quad
% 		        04 \quad
% 		        00
% 		    $$
% 		\pause\item Modern PCs (Intel x86 based) use little endian
% 		\pause\item Little endian may seem unintuitive
% 		\pause\item However it is more efficient when programs need to convert one size of integer to another
% 	\end{itemize}
% \end{frame}

\begin{frame}{Floating point numbers}
	\begin{itemize}
		\pause\item What about storing non-integer numbers?
		\pause\item Usually we use \textbf{floating point} numbers
		\pause\item Python type: \lstinline{float}
		\pause\item Details on in-memory representation later in the module
		\pause\item (Note: \lstinline{float} in Python 3 has the same precision as \lstinline{double} in C++/C\#/etc)
	\end{itemize}
\end{frame}

\begin{frame}{Integers vs floating point numbers}
	\begin{itemize}
		\pause\item \lstinline{int} and \lstinline{float} are different types!
		\pause\item \lstinline{42} and \lstinline{42.0} are technically different values
			\begin{itemize}
				\pause\item One is an \lstinline{int}, the other is a \lstinline{float}
				\pause\item They are stored differently in memory (completely different sequences of bytes)
				\pause\item However \lstinline{==} etc still know how to compare them sensibly
			\end{itemize}
	\end{itemize}
\end{frame}

% \begin{frame}{Other number formats}
% 	\begin{itemize}
% 		\pause\item \textbf{Fixed point}: alternative format for non-integer numbers
%             \begin{itemize}
%                 \pause\item More on this later
%                 \pause\item E.g.\ \lstinline{decimal} module in Python
%             \end{itemize}
%         \pause\item \textbf{Rational numbers}: store fractions as numerator and denominator
%             \begin{itemize}
%                 \pause\item E.g.\ \lstinline{fractions} module in Python
%             \end{itemize}
%         \pause\item \textbf{Complex numbers}: stored as a pair of floating point numbers for real and imaginary parts
%             \begin{itemize}
%                 \pause\item E.g.\ \lstinline{complex} type in Python
%             \end{itemize}
% 	\end{itemize}
% \end{frame}

