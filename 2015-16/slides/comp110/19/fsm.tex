%\part{Finite state machines}
%\frame{\partpage}

\begin{frame}{Finite state machines}
    \begin{itemize}
        \item A \textbf{finite state machine (FSM)} consists of: \pause
            \begin{itemize}
                \item A set of \textbf{states}; and \pause
                \item \textbf{Transitions} between states \pause
            \end{itemize}
        \item At any given time, the FSM is in a \textbf{single state} \pause
        \item \textbf{Inputs} or \textbf{events} can cause the FSM to transition to a different state
    \end{itemize}
\end{frame}

\begin{frame}{State transition diagrams}
    \begin{center}\scalebox{0.8}{
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm,
                            semithick]
            \node[initial,state] (A) {a state};
            \node[state] (B) [right of=A, align=center] {another\\state};

            \path (A) edge [bend left] node [above] {transition} (B)
                  (B) edge [bend left] node [below] {transition} (A)
                  (A) edge [loop above] node {loop} (A);
        \end{tikzpicture}
    }\end{center}
    \begin{itemize}
        \item FSMs are often drawn as \textbf{state transition diagrams}
        \item Reminiscent of \textbf{flowcharts} and certain types of \textbf{UML diagram} \pause
    \end{itemize}
\end{frame}

\begin{frame}{FSMs for AI behaviour}
    The next slide shows a simple FSM for the following AI behaviour, for an enemy NPC in a shooter game: \pause
    \begin{itemize}
        \item By default, patrol (e.g.\ along a preset route) \pause
        \item If the player is spotted, attack them \pause
        \item If the player is no longer visible, resume patrolling \pause
        \item If you are low on health, run away and find a medikit. Then resume patrolling \pause
        \item If you are low on ammo, run away and find ammo. Then resume patrolling \pause
    \end{itemize}
\end{frame}

\begin{frame}
    \begin{center}\scalebox{0.8}{
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm,
                            semithick]
            \node[initial,state] (patrol) {patrol};
            \node[state] (health) [above right of=patrol, align=center] {seek\\medikit};
            \node[state] (ammo) [below right of=patrol, align=center] {seek\\ammo};
            \node[state] (attack) [above right of=ammo] {attack};

            \path (patrol) edge [bend left] node [below] {player visible} (attack)
                  (attack) edge [bend left] node [above] {player not visible} (patrol)
                  (attack) edge node [above right] {low health} (health)
                  (attack) edge node {out of ammo} (ammo)
                  (health) edge node [above left] {medikit found} (patrol)
                  (ammo) edge node {ammo found} (patrol);
        \end{tikzpicture}
    }\end{center}
\end{frame}

\begin{frame}{Activity}
    \begin{itemize}
        \item In your \textbf{COMP150 groups}, on the \textbf{whiteboards}
        \item \textbf{Extend} the FSM on the previous slide to produce \textbf{more realistic behaviour}
        \item Add at least \textbf{two} states, and associated transitions
        \item \textbf{5 minutes}...
    \end{itemize}
\end{frame}

\begin{frame}{Other uses of FSMs}
    As well as AI behaviours, FSMs may also be used for: \pause
    \begin{itemize}
        \item UI menu systems \pause
        \item Dialogue trees \pause
        \item Token parsing \pause
        \item ...
    \end{itemize}
\end{frame}

\begin{frame}{Activity}
    \begin{itemize}
        \item In your \textbf{COMP150 groups}, on the \textbf{whiteboards}
        \item \textbf{Draw} an FSM for the overall UI structure of a typical game
        \item Include \textbf{at least} the following states, and appropriate transitions:
            \begin{itemize}
                \item Main menu
                \item Options menu
                \item Game screen
                \item Pause menu
                \item Exit
            \end{itemize}
        \item \textbf{5 minutes}...
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{FSMs in C++: Option 1}
    Use an \textbf{enum} to represent the states:
    \begin{lstlisting}
enum class SoldierState
{
    Patrol, Attack, SeekMedikit, SeekAmmo
};
    \end{lstlisting} \pause
    Store the \textbf{current state} as a field, initialised to the start state:
    \begin{lstlisting}
SoldierState currentState = SoldierState::Patrol;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    Use a \textbf{switch} statement to implement the FSM itself:
    \begin{lstlisting}
void Soldier::update()
{
    switch (currentState)
    {
    case SoldierState::Attack:
        attack();
        
        if (!isPlayerVisible())
            currentState = NPCState::Patrol;
        else if (health < LOW_HEALTH_THRESHOLD)
            currentState = NPCState::SeekMedikit;
        else if (ammo == 0)
            currentState = NPCState::SeekAmmo;
        break;
    // ...
    }    
}
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{FSMs in C++: Option 2}
    Use \textbf{classes} to represent the states:
    \begin{lstlisting}
class SoldierState
{
public:
    virtual void update(Soldier& soldier) = 0;
};

class SoldierAttackState : public SoldierState
{
public:
    virtual void update(Soldier& soldier);
};
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Implementing FSMs: Option 2}
    Store the current state as a (pointer to an) \textbf{instance} of a state class:
    \begin{lstlisting}
std::shared_ptr<SoldierState> currentState
    = std::make_shared<SoldierPatrolState>();
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    Use \textbf{virtual method overriding} to implement behaviour:
    \begin{lstlisting}
void SoldierAttackState::update(Soldier& soldier)
{
    soldier.attack();
    
    if (!soldier.isPlayerVisible())
        soldier.currentState
            = std::make_shared<SoldierPatrolState>();
    else if (soldier.health < LOW_HEALTH_THRESHOLD)
        soldier.currentState
            = std::make_shared<SoldierSeekMedikit>();
    else if (soldier.ammo == 0)
        soldier.currentState
            = std::make_shared<SoldierSeekAmmo>();
}
    \end{lstlisting}
\end{frame}

\begin{frame}{Beyond FSMs}
    Some topics for you to research, for when plain old FSMs aren't enough... \pause
    \begin{itemize}
        \item Hierarchical FSMs
        \item Nested FSMs
        \item Stack-based FSMs
        \item Behaviour trees
        \item Hierarchical task networks
        \item ...
    \end{itemize}
\end{frame}

\begin{frame}{Summary}
    \begin{itemize}
        \item Finite state machines (FSMs) can be used to model systems which have
            \textbf{one state} at any given time, and where inputs or events trigger \textbf{transitions} between states
        \item In games, often used for \textbf{simple AI behaviours} and for handling transitions between \textbf{UI screens}
        \item Can be implemented using \textbf{enums} and \textbf{switch} statements,
            or using \textbf{classes} and \textbf{polymorphism}
    \end{itemize}
\end{frame}
